[来源](https://www.nowcoder.com/discuss/721039224941625344?sourceSSR=search)

# MySQL 事务隔离级别？默认隔离级别？

MySQL 提供 **4 种事务隔离级别**，主要用于解决 **脏读（Dirty Read）**、**不可重复读（Non-Repeatable Read）**、**幻读（Phantom Read）** 等问题：

| **隔离级别**                        | **脏读（Dirty Read）** | **不可重复读（Non-Repeatable Read）** | **幻读（Phantom Read）**       |
| ------------------------------- | ------------------ | ------------------------------ | -------------------------- |
| **READ UNCOMMITTED（读未提交）**      | ✅ 可能发生             | ✅ 可能发生                         | ✅ 可能发生                     |
| **READ COMMITTED（读已提交）**        | ❌ 避免脏读             | ✅ 可能发生                         | ✅ 可能发生                     |
| ==**REPEATABLE READ（可重复读）**默认== | ❌ 避免脏读             | ❌ 避免不可重复读                      | ✅ 可能发生（可以通过间隙锁 Gap Lock解决） |
| **SERIALIZABLE（可串行化）**          | ❌ 避免脏读             | ❌ 避免不可重复读                      | ❌ 避免幻读                     |

---

**1. READ UNCOMMITTED（读未提交）**
**✅ 允许读取未提交的数据（可能发生脏读）**
• 事务可以读取 **其他事务未提交的修改**，可能导致读取到错误的数据（**脏读**）。
• **不使用 MVCC**，直接读取数据。
• 适用于 **不关心数据一致性，但希望事务执行速度最快的场景**。
**🔹 机制**
• **直接读取最新的数据行**，无论该数据是否被其他事务修改或提交。
• **没有任何一致性保证**，可能读取到不稳定的数据。

**2. READ COMMITTED（读已提交）**
**✅ 只允许读取已提交的数据（避免脏读）**
• 事务只能读取 **已经提交的数据**，避免了**脏读**。
• 但 **不可重复读** 仍然可能发生。
**🔹 机制**
• **MVCC 实现**：每次 SELECT 语句都会读取最新的已提交版本。
• **不会读取未提交的数据**，但如果事务多次读取同一行数据，可能会读到 **不同的值**。

**3. REPEATABLE READ（可重复读，MySQL 默认）**
**✅ 确保同一事务内的多次查询结果一致（避免不可重复读）**
• **事务开始后，读取的数据不会变化**（即使其他事务修改并提交）。
• **MVCC 机制** 保证事务 **只能看到事务开始时的快照版本**（**一致性视图**）。
• **可能会发生幻读**，但 MySQL **通过** **间隙锁（Gap Lock）** **防止幻读**。
**🔹 机制**
• **MVCC 实现**：事务开始时创建一个 **一致性快照**（ReadView），所有 SELECT 语句都读取 **该事务开始时的快照**，即使其他事务修改并提交，也不会影响当前事务的读取。
• **对于 UPDATE/DELETE 语句，MySQL 采用 行锁 + 间隙锁，确保数据不会发生幻读**。

**4. SERIALIZABLE（可串行化）**
**✅ 最高级别的隔离，所有事务串行执行**
• **强制事务串行执行，避免所有并发问题（包括幻读）**。
• 通过 **表锁或行锁** 让事务 **逐个执行**，降低并发性能。
**🔹 机制**
• **默认使用** **SELECT ... FOR UPDATE** **加锁**，所有事务按照顺序执行，保证一致性。
• **完全避免了脏读、不可重复读、幻读，但吞吐量最低**。

---

**1. 脏读（Dirty Read）**
**定义**
• **事务 A 读取了事务 B 未提交的数据**，如果事务 B 回滚了，则事务 A 读取的数据就是 **错误数据**。
1. **事务 A** 读取 balance = 100。
2. **事务 B** 修改 balance = 200 **但未提交**，事务 A 读取了这个新值（**脏读**）。
3. **事务 B** 回滚后，balance 仍然是 100，但事务 A 仍然保留 200，导致数据不一致。

**2. 不可重复读（Non-Repeatable Read）**
**定义**
• **同一个事务内，多次查询同一行数据，数据内容发生了变化**（事务 B **修改了数据并提交**）。
• **影响的是数据的值**。
**示例**
1. **事务 A** 读取 balance = 100。
2. **事务 B** 修改 balance = 200 并提交。
3. **事务 A** **再次查询时，发现数据变成了 200（不可重复读）**。

**3. 幻读（Phantom Read）**
**定义**
• **同一个事务内，多次查询，发现 “行的数量” 发生了变化**（事务 B **插入/删除了数据**）。
• **影响的是数据的行数**。
**示例**
1. **事务 A** 查询 salary > 5000 的用户，结果有 10 条数据。
2. **事务 B** 插入一条 salary = 6000 的用户并提交。
3. **事务 A** **再次查询，发现结果多了一条（幻读）**。



# 存储引擎？InnoDB 和 MyISAM 区别。
| **特性**   | **InnoDB**                            | **MyISAM**            |
| -------- | ------------------------------------- | --------------------- |
| **事务支持** | ✅ 支持（ACID、事务）                         | ❌ 不支持事务               |
| **锁机制**  | **行级锁**（提高并发性能）                       | **表级锁**（并发性能较差）       |
| **外键支持** | ✅ 支持                                  | ❌ 不支持                 |
| **查询性能** | 适用于 **高并发写入场景**                       | 适用于 **查询密集型场景**（读操作快） |
| **数据安全** | **支持崩溃恢复**，采用 **redo log 和 undo log** | **不支持崩溃恢复**，数据容易丢失    |
| **全文索引** | ❌ 以前不支持（MySQL 5.6+ 开始支持）              | ✅ 支持全文索引              |
| **空间占用** | **较大**（有事务日志）                         | **较小**                |
| **适用场景** | **事务型应用**（如银行系统、电商订单）                 | **读密集型应用**（如日志、CMS）   |

# MVCC

**📌 MVCC 的实现原理**
MVCC 依赖于 **隐藏字段 + Undo Log + ReadView** 机制来实现 **数据的多版本控制**。

**🔹 1. MVCC 依赖的隐藏字段**
在 **InnoDB** 存储引擎中，每个数据行都有两个 **隐藏字段**：
• trx_id：记录 **最近修改该行的事务 ID**。
• roll_pointer：指向 **Undo Log（回滚日志）**，用于存储旧版本数据。

👉 示例（事务执行过程）
 **🔹 事务 A 插入数据（trx_id = 100）**
```sql
-- 事务 A 插入数据（trx_id = 100）
INSERT INTO users (id, name) VALUES (1, 'Alice');
```


| id  | name  | trx_id（最近修改的事务 ID） | roll_pointer（回滚指针） |
| --- | ----- | ------------------ | ------------------ |
| 1   | Alice | 100                | NULL               |

**🔹 事务 B 修改数据（trx_id = 101）**
```sql
-- 事务 B 修改数据（trx_id = 101）
UPDATE users SET name = 'Bob' WHERE id = 1;
```
事务 B 生成了一个 **新版本数据**，但老版本数据不会被删除，而是存入 **Undo Log**：

| id  | name  | trx_id | roll_pointer |
| --- | ----- | ------ | ------------ |
| 1   | Bob   | 101    | 指向旧版本数据      |
| 1   | Alice | 100    | NULL         |

📌 **事务 A 仍然能看到旧版本（Alice），而事务 B 看到 Bob。**

--- 

**🔹 2. Undo Log（回滚日志）**
• **作用**：存储数据的 **旧版本**，用于实现 **一致性读** 和 **事务回滚**。
• **实现方式**：每次 UPDATE 操作，都会把旧数据存入 Undo Log，新数据写入数据表。

📌 **读取数据时，MVCC 通过 roll_pointer 找到 Undo Log 里的老版本数据**，保证事务的 **一致性读取**

---

**🔹 3. ReadView（一致性视图）**

• **ReadView 是 MVCC 关键机制**，用于**控制事务读取的可见性**。
• **作用**：决定 **当前事务可以看到哪些版本的数据**。
• **实现方式**：
1. **事务开始时**，生成一个 **ReadView**，记录**当前活跃的事务 ID**（trx_id）。
2. **查询数据时**，判断数据行的 trx_id 是否符合当前事务的可见性规则。

📌 **ReadView 作用：**
• **小于 ReadView 记录的最小事务 ID** → ✅ **可见**
• **大于当前事务的 ID** → ❌ **不可见**
• **在 ReadView 记录的事务列表中** → ❌ **不可见（未提交的事务）**