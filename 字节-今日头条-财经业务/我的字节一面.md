
# Token与Session的区别是什么？

**1. 存储位置不同**
• **Session**：由服务端生成并存储在服务端内存或持久层（如Redis）中，客户端只保存一个Session ID。
• **Token**：由服务端生成后返回给客户端，客户端（通常是浏览器或App）持有Token并在每次请求中携带，服务端不保存用户状态。


**2. 扩展性和分布式支持**
• **Session**：在分布式系统中需要做Session共享（如使用Redis集中存储Session），否则用户在不同服务器上会频繁登录失效。
• **Token**：天然支持分布式，因为服务端不保存状态，只要能验证Token即可，适合微服务架构。


在我的项目里，session是HttpSession实现，会存储在服务器，但没办法跨服务器使用。所以使用了token解决这个问题。
当你第一次访问 /sendCode 接口时：
1. 浏览器没有 Session ID，Tomcat 自动创建一个新的 Session；
2. 然后通过响应头 Set-Cookie 把 JSESSIONID=xxx 发送到浏览器；
3. 下次请求时，浏览器会自动带上 Cookie: JSESSIONID=xxx；
4. 服务端通过这个 ID 找回之前的 HttpSession 对象，实现会话保


# 讲讲你的Token实现

在用户登录的时候会随机生成Token(UUID)作为登陆令牌，然后把用户数据用Token作为key，存到redis里面。然后把token返回回去



# 为什么Token要存入Redis？是否可以直接使用Token？

**✅ 1. 直接用 Token 也可以，但不够安全 & 不可控**

最典型的“直接用 token”方案是 **JWT（JSON Web Token）**：

• JWT 把用户信息直接编码进 token（如用户ID、角色、过期时间等）；

• 服务端只需要验证签名和过期时间即可，不用查询 Redis。  

**听起来确实是“无状态”且高效，但问题来了：**

• JWT 一旦发出去，服务端就**无法手动失效**（比如强制下线、注销用户、修改用户权限时）；

• token 泄露后，即使用户已经登出、换密码，别人依然可以拿旧 token 正常请求；

• 过期之前，JWT 就像“失控的门票”，服务端无法干预。

👉 所以 **JWT 适合安全要求不那么高、或只能做短时认证的场景**。

---

**✅ 2. 把 Token 存入 Redis，是为了“可控、安全、可扩展”**

你现在的做法是：

• 登录后生成一个随机 token；

• 把 token 作为 Redis 的 key，用户信息作为 value 存进去；

• 前端每次请求带上 token；

• 服务端从 Redis 拿到对应用户信息，完成认证。


这种方式的优势在于：

**✅ ① 服务端可控（随时注销/强制失效）**

你可以：

• 设置 Redis 过期时间；

• 用户主动登出时删除 token；

• 管理后台强制踢人、限制登录等。

**✅ ② 服务端可以动态续期**

你项目中就做了这一点：
```
stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);
```

也就是**每次请求后自动延长登录有效期**，提高用户体验。

**✅ ③ 支持复杂用户模型**
你可以在 Redis 中存储的不止是用户ID，还可以是整个 UserDTO，甚至加上登录设备、权限等级等。

**✅ ④ 安全性更高**

Token 是随机字符串，没有包含用户敏感信息，**即使被盗用也可以通过 Redis 控制其有效性**，更安全。

---

**✅ 3. 总结一句话（面试话术）：**


> 虽然直接用 Token（如 JWT）可以做到无状态认证，但不利于服务端控制、强制失效或续签；而将 Token 存入 Redis 是一种“伪无状态”的设计，结合了高并发支持和服务端可控的优点，特别适合需要高安全性、动态权限控制的业务场景。

---


# 