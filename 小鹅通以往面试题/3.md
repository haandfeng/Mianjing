[来源](https://www.nowcoder.com/feed/main/detail/cccca68cf11e4c68b35d8e3261dd9b44?sourceSSR=enterprise)

#### 直播时，上架热门商品如何设计？


#### 直播发放优惠券如何设计？


#### 把优惠券都放在Redis里扣减，如果Redis扛不住压力怎么办？

把优惠卷放到不同的分片集群
#### 把优惠卷放到不同的分片集群，会有什么问题？
会存在某个集群的优惠券已经为零，其他集群不为零，导致存在优惠券的情况下，用户抢不到优惠券

#### 如何解决这个问题
定时任务检测

**一致性哈希**：
• 可以考虑使用一致性哈希（Consistent Hashing）策略来分配优惠券到不同的 Redis 分片，这样可以避免因为单个分片库存耗尽导致的用户无法领取的问题。
#### Redis热key如何处理

**Redis 热key**是指 Redis 中被频繁访问或请求的某些键（key），这些键的访问频率远高于其他键。热key 通常会导致以下问题：
• **高并发访问**：大量的请求集中到某个 key 上，造成该 key 的访问压力大，可能导致 Redis 单个节点过载，影响系统的整体性能。
• **内存压力**：如果热key 存储的数据很大，频繁访问会导致 Redis 内存占用急剧增加，影响其他数据的存取。
• **单点瓶颈**：当热key 被多个请求并发访问时，可能导致 Redis 的单个实例成为瓶颈，降低系统整体的响应速度和吞吐量。

处理：
小林
- ﻿在Redis集群架构中对热Key进行复制。在Redis集群架构中，由于热Key的迁移粒度问题，无法将请求分散至其他数据分片，导致单个数据分片的压力无法下降。此时，可以将对应热Key进行复制并迁移全其他数据分片，例如将热Key foo复制出3个内容完全一样的Key并名为fo02、f003、f004，将这三个Key迁移到其他数据分片来解决单个数据分片的热Key压力。
- ﻿使用读写分离架构。如果热Key的产生来自于读请求，您可以将实例改造成读写分离架构来降低每个数据分片的读请求压力，甚至可以不断地增加从节点。但是读写分离架构在增加业务代码复杂度的同时，也会增加Redis集群架构复杂度。不仅要为多个从节点提供转发层（如Proxy，LVS等）来实现负载均衡，还要考虑从节点数量显著增加后带来故障率增加的问题。Redis集群架构变更会为监控、运维、故障处理带来了更大的挑战。
GPT
**1. 热点数据分散**
• **分布式缓存**：通过 Redis 集群或分片，将数据分布到多个 Redis 实例上。热点数据会被分配到不同的分片，这样可以避免单个节点上的热点数据导致资源占用过高。
• **使用一致性哈希**：一致性哈希算法可以有效地分配热点数据到不同的 Redis 分片上，避免某个分片成为瓶颈。
**2. 使用多级缓存**
• **多级缓存结构**：可以在 Redis 外层增加一个本地缓存（如 Guava、Caffeine 等），这样当 Redis 作为第二级缓存时，可以减轻 Redis 的访问压力。对于频繁访问的数据，首先查本地缓存，再查 Redis，避免 Redis 成为单点瓶颈。
#### Redis和mysql缓存一致性如何保证？

**1. 使用写操作时的缓存更新策略**
• **缓存更新策略**：每次数据库更新操作（如插入、更新、删除）后，立即更新或删除缓存中的对应数据。
• **更新缓存**：当 MySQL 中的数据发生更改时（例如，更新用户信息），应该直接更新 Redis 中的缓存，确保缓存与数据库的数据一致性。
• **删除缓存**：当数据更新时，删除 Redis 中的相关缓存，让下次请求重新从数据库加载最新的数据到缓存中。

**2. 设置合理的缓存过期时间（TTL）**

**3. 使用双写策略（Write-through 和 Write-behind）**
• **Write-through**：每次写操作时，同时更新缓存和数据库。即在数据库操作成功后，立刻更新缓存。这种方式确保数据一致性，但会增加写操作的延迟，因为每次都要同时更新缓存和数据库

• **Write-behind**：先更新缓存，异步将更新操作推送到数据库。这种方式能够提高写操作的性能，但可能会出现数据库和缓存不一致的短暂时段，因为更新数据库的操作是异步的。

**4. 读取时的缓存回源（Cache Aside）**

在某些情况下，可以使用 **Cache Aside**（缓存旁路）模式进行缓存更新。在这种模式下，只有当缓存失效或缓存中没有数据时，才会从数据库加载数据并将其缓存起来。这种模式避免了缓存与数据库之间的写入同步问题，但可能会引入缓存穿透的问题。

• **读取时先查询缓存**：如果缓存中有数据，直接返回缓存的数据。
• **缓存未命中时查询数据库**：如果缓存中没有数据，则查询数据库，并将查询到的数据放入缓存中。