[来源](https://www.nowcoder.com/discuss/402428061331849216?sourceSSR=users)

# tcp三次握手的流程，为什么不能二次握手
[详情](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)
第一次: 客户端发网络包：SYN=1，Seq Num = client_isn
第二次：服务端回应: SYN=1 ACK=1 Seq Num=server_isn  Ack=client_isn+1
第三次：客户段回应 ACK=1，Seq Num=client_isn+1 Ack=Server isn+1


# 三次握手期间可以传输数据吗？


很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的

接下来，以三个方面分析三次握手的原因：

- ﻿﻿三次握手才可以阻止重复历史连接的初始化（主要原因）
- ﻿﻿三次握手才可以同步双方的初始序列号
- ﻿﻿三次握手才可以避免资源浪费

相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”


原因一：避免历史连接
如果是两次握手连接，就无法阻止历史连接，那为什么 TCP 两次握手为什么无法阻止历史连接呢？

1. 我先直接说结论，主要是因为在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。

可以看到，如果采用两次握手建立 TCP连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，受妥地浪费了服务端的资源。

因此，要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。

所以，TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。



原因二：同步双方初始序列号

TCP协议的通信双方，都必须维护一个「序列号J，序列号是可靠传输的一个关键因素，它的作用：

- ﻿﻿接收方可以去除重复的数据；
- ﻿接收方可以根据数据包的序列号按序接收；
- ﻿可以标识发送出去的数据包中，哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；

可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。


原因三：避免资源浪费

如果只有「两次握手」，当客户端发生的 SYN 报文在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN，由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？

如果客户端发送的 SYN 报文在网络中阻塞了，重复发送多次 SYN 报文，那么服务端在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。



# 为什么只有第三次可以，第一次不行吗？

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。

而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。


• 在 SYN 阶段，TCP **尚未完全建立连接**，接收端无法为该连接**分配缓存和资源**，因此不允许携带数据。

• 服务器尚未为该连接分配接收缓存，如果 SYN 携带数据，服务器无法处理。

• 服务器在 **发送 SYN+ACK 时，仍然不知道客户端是否真的能收到这个包**。

• 服务器此时**还未完全建立连接**，如果 SYN+ACK 携带数据，而客户端没有响应，数据可能会丢失。

• **安全问题**：如果 SYN+ACK 携带数据，攻击者可以利用 SYN Flood 发送大量伪造的 SYN，导致服务器资源耗尽。
  


# sql语句的执行流程（只说了from最先 limit最后）
1. **FROM** —— 确定数据来源，建立数据集合
2. **ON** —— 处理 JOIN 关联条件
3. **JOIN** —— 连接表（如果有）
4. **WHERE** —— 过滤数据，排除不符合条件的行
5. **GROUP BY** —— 按指定列分组
6. **HAVING** —— 过滤分组后的数据
7. **SELECT** —— 选择查询的列（包括计算、聚合函数）
8. **DISTINCT** —— 去重
9. **ORDER BY** —— 按指定列排序
10. **LIMIT** —— 限制返回的行数


# sql的引擎数据结构

| 存储引擎    | 主要数据结构        | 适用场景      |
| ------- | ------------- | --------- |
| InnoDB  | B+ 树（索引）+ 页存储 | 事务、索引查询   |
| MyISAM  | B+ 树 + 压缩表    | 高并发读      |
| Memory  | 哈希表           | 临时存储、高速查询 |
| RocksDB | LSM 树         | 日志存储、批量写  |

# 为什么b+树比b树好
![[广州兴业#为什么MySQL 采用 B+ 树作为索引]]