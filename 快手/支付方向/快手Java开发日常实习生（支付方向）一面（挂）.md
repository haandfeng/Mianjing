[快手Java开发日常实习生（支付方向）一面（挂）](https://www.nowcoder.com/feed/main/detail/4968ffa543664c63a7a1cb3cf965c55f?sourceSSR=search)

1. 问项目  
2. MySQL除了binlog还有什么日志？  
3. 如果进行了insert，在MySQL中三个log的写入顺序  
4. binlog提交失败了怎么办  
5. 这几个log分别在MySQL中的那一层？比如服务层，引擎层  
6. MySQL的默认的隔离级别  
7. 在RR下还会发生幻读问题吗  
==看前面的==

8. 当一个服务从请求量比较小到中等到特别大，针对这个服务能够做的改造是什么？（多个方面的，比如缓存，数据库，中间件，服务器的数量，每一个阶段什么样的投入才是最有效果的）  

| **阶段** | **架构特点**       | **最有效投入**             |
| ------ | -------------- | --------------------- |
| 小流量阶段  | 单体应用，单机部署      | 快速上线、保证功能正确，控制成本      |
| 中等流量阶段 | 初步拆分，读写分离，加入缓存 | Redis 缓存、读写分离、中间件限流熔断 |
| 高流量阶段  | 分布式、微服务、集群化    | 分库分表、微服务治理、自动扩容与容     |


9. 如果说一张优惠券每个用户限领10张，但是他点了11次会怎么样？  

**3. 后端使用了并发控制：行为受限，符合预期**
最常见有以下几种防止超发的方式：
**a. 数据库层面加锁（悲观锁 / 乐观锁）**
• **悲观锁：** select ... for update 锁住用户的优惠券记录，串行化更新。
• **乐观锁：** 加版本号或条件判断防止并发写入。
**b. 使用 Redis 计数 + 分布式锁**
• 每个用户领取时使用 Redis 的 INCR 命令统计领取次数。
• 超过10就直接返回失败。
• 使用分布式锁（如 Redisson）包裹领取逻辑，防止并发执行超发。
**c. 使用 Lua 脚本原子性操作（推荐）**
在 Redis 中执行如下逻辑的 Lua 脚本，保证操作的原子性：`
```lua 
if redis.call('GET', key) < 10 then
    redis.call('INCR', key)
    return true
else
    return false
end
```

10. 在对数据库的操作解耦之前，为什么MySQL这么慢？（前面说了一开始QPS只有10几，解耦后有500多）
项目内容不回复
11. explain能提供什么信息？  

**1. id：查询中语句的执行顺序**
• 每一行代表执行计划中的一个操作步骤。
• 数字越大，执行优先级越高。
• 如果是联合查询或子查询，会有多个不同的 id，方便你看出哪部分先执行。

---
**2. select_type：查询的类型**
说明这一行是普通查询、子查询、还是派生表等。常见值：
• SIMPLE：简单查询，没有子查询或 UNION。
• PRIMARY：最外层查询。
• SUBQUERY：在 SELECT 或 WHERE 中出现的子查询。
• DERIVED：派生表（子查询生成的临时表）。
• UNION / UNION RESULT：与 UNION 相关的查询。

| **Select_type** | **说明**               | **例子位置**                 |
| --------------- | -------------------- | ------------------------ |
| SIMPLE          | 普通查询，没有子查询或 UNION    | 单表 SELECT                |
| PRIMARY         | 最外层的 SELECT 查询       | 包含子查询时的主查询               |
| SUBQUERY        | WHERE 或 SELECT 中的子查询 | WHERE id IN (SELECT ...) |
| DERIVED         | FROM 中的子查询（变成临时表）    | FROM (SELECT ...) AS tmp |
| UNION           | UNION 中的后续查询         | 第二个 SELECT 开始            |
| UNION RESULT    | UNION 合并后的最终输出       | UNION 执行计划中的最后一行         |

---

**3. table：当前访问的表名或别名**
显示当前这一步要访问的表，有助于定位某张表是否是瓶颈。

---
**4. type：连接类型（访问方式）——非常关键！**
这是性能优化中最需要关注的一列，从好到差大致如下： 

| **type** | **含义**                 |
| -------- | ---------------------- |
| const    | 常量表，只访问一次，非常快。         |
| eq_ref   | 唯一索引等值连接，每次只返回一条记录。    |
| ref      | 非唯一索引扫描，可能返回多条记录。      |
| range    | 索引范围扫描，如 BETWEEN、IN。   |
| index    | 扫描整个索引，比全表快但仍较重。       |
| ALL      | 全表扫描 —— 说明没有走索引，是性能问题！ |
> 一般期望看到的是 const、eq_ref 或 range，避免 ALL。

**5. possible_keys：可能使用的索引**
列出当前查询能使用的索引，但不代表最终会使用它。

---
**6. key：实际使用的索引**
如果这个值为 NULL，说明该查询没有使用任何索引，通常是性能问题。

---
**7. key_len：使用索引的长度**
• 表示 MySQL 实际使用了索引的多少字节。
• 通过这个可以判断是否用了复合索引的所有字段（只用了部分字段也会导致效率下降）。

---
**8. ref：与索引字段进行比较的字段或常量**
比如：用 user_id = 10 查询时，这里会显示常量 const。

---
**9. rows：MySQL 估计要读取的行数**
• 是一个估算值，不一定准，但能大致反映 SQL 的代价。
• 如果这里是几十万行而不是几十行，那你要特别留意这一步的效率问题。

---

**10. Extra：额外信息，异常或优化提示都在这**

|**Extra**|**含义说明**|
|---|---|
|Using index|使用了“覆盖索引”，无需回表，效率较高。|
|Using where|使用了 WHERE 过滤条件，但不一定走了索引。|
|Using filesort|MySQL 需要额外排序，性能较差，应尽量避免。|
|Using temporary|使用临时表，通常由 GROUP BY 或 ORDER BY 引起。|
|Using index condition|使用了 Index Condition Pushdown（ICP），优化范围过滤。|
|Using join buffer|没有走索引的 join，MySQL 使用了内存做连接缓冲，效率较低。|

12. 还了解过其他消息队列吗？  
13. SpringBoot和传统的双亲委派有什么不一样吗  
还没学，不写了

==14. 代码（字符串数组，返回连续出现N次“A”的次数）  == 看前面的
  
