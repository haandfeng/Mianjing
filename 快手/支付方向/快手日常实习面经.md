
# 一面-0218

1. 自我介绍
2. 服务的注册发现流程
	serviceKey: ServiceName+ServiceVersion
	NodeKey: serviceKey+Host+Port
	存储：
		存在Etcd的key是ETCD_ROOT_PATH+整个Nodekey，值是类serviceMetaInfo的Json格式，30S内过期
	发现：
		通过ETCD_ROOT_PATH+serviceKey前缀搜索服务，搜索到存在Etcd的Json格式类，转成Bean返回
		
	
3. 获取服务列表的并发安全问题
4. 如果获取到servicelist后，某台服务不可用了，会怎么样？
5. 随机负载均衡如何实现的？
6. 熔断器如何实现的
7. 限流器如何实现
8. 固定窗口的限流算法实现；状态的记录、状态的变更滑动窗口的限流算法实现
9. 优惠券的秒杀实现原理：
10. 锁的key是什么
11. 为什么用redis预先领取+MQ落库
12. 如果一个用户同时发起多个请求，可以避免该用户超领吗
13. 原子类如何实现的？
14. 算法：
15. 画出B+树结构
16. 一些sql场景，会不会走索引。联合索引在 > 和 >= 的不同
17. 岛屿数量

  


Raft原理

**一、Raft 的核心目标**
在分布式系统中，多个服务器（节点）通常需要共同维护一份数据（比如日志、副本、配置等）。Raft 的目标是确保这些服务器中的多数能够就数据的**顺序和内容**达成一致，即使部分服务器失败或出现网络分区，也能保证系统整体的一致性。

---
**二、基本概念和术语**

• **节点角色**：Raft 中的每个节点在任何时刻都有以下三种角色之一：
	• **Leader（领导者）**：负责处理客户端请求，并将请求以日志形式同步给其他节点。
	• **Follower（跟随者）**：响应 Leader 的指令，不主动发起动作。
	• **Candidate（候选人）**：在选举过程中产生，竞选成为新的 Leader。

• **任期（Term）**：时间被划分为多个任期，每个任期开始于一次选举。任期是 Raft 判断信息是否“过时”的基础。

• **日志（Log）**：每个节点都有一份日志，包含多个条目，每条记录客户端的一个操作。Raft 保证这些日志在多数节点上一致。

---

**三、核心机制**
**1. Leader 选举（Leader Election）**
• 初始时，所有节点都是 Follower。

• 一段时间内没有收到 Leader 的心跳（心跳即 AppendEntries 消息），Follower 会变为 Candidate，发起**投票请求（RequestVote）**。

• 每个节点每个任期只投票给一个候选人。

• 候选人如果获得多数节点（超过一半）的投票，就成为 Leader。

• Leader 上任后，开始发送定期心跳，告诉其他节点“我还在”。

  

**2. 日志复制（Log Replication）**

• 客户端请求发送给 Leader。

• Leader 将请求写入自己的日志，并向 Follower 发送 AppendEntries 消息。

• 如果大多数节点都成功写入该日志，Leader 就将该条目标记为“已提交”，并通知 Follower 提交执行。

• 所有节点都会按相同顺序执行日志，确保一致性。

  
**3. 日志一致性原则**

Raft 保证日志的一致性主要靠这两个原则：

• **日志匹配原则**：如果两个日志在同一位置有相同的任期号和索引，**那么它们之前的日志一定完全相同**。

• **Leader 限制原则**：Leader 必须拥有“最新的日志”才能被选中。这保证了新 Leader 不会丢失旧 Leader 提交过的日志。

  

**4. 安全性与可恢复性**

• **多数派原则**：只要大多数节点存活，系统就能继续工作。

• **崩溃恢复**：Raft 依靠持久化日志和快照机制（Snapshot）来在节点重启后恢复状态。