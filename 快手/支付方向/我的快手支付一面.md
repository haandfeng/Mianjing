
# 自我介绍

# 看你的编程语言C++，Python，Java，PHP都用过，你都用来干嘛

随便讲一下

# 对比Java C++ Python的区别
我的说法是Java能跨平台，主要开发Web程序，业务程序
C++偏低层实现，能调用一些系统内部接口
Python做深度学习作业，做脚本处理数据（也可以说自己写过小游戏）

| **场景**       | **推荐语言**                  | **理由**     |
| ------------ | ------------------------- | ---------- |
| 企业级系统、Web 后端 | Java                      | 成熟稳定，生态完善  |
| 游戏引擎、系统编程    | C++                       | 性能极致，底层控制强 |
| AI、数据科学、脚本工具 | Python                    | 开发快，工具链强   |
| 跨平台移动应用      | Java（Android）/ Python（原型） | 支持广泛       |
| 高频交易 / 嵌入式系统 | C++                       | 实时性要求高     |
# 他们在编译执行上的区别
**Java：编译为字节码，运行在 JVM 上**
```sh
java Hello → JVM 加载 class → 解释执行 / JIT 编译为机器码
```
**C++：直接编译为本地机器码**
**Python：解释执行（或编译为字节码再解释）**

| **语言**     | **编译过程**                    | **执行方式**              | **中间产物**          | **依赖环境**              |
| ---------- | --------------------------- | --------------------- | ----------------- | --------------------- |
| **C++**    | 源码 → 编译器 → 本地机器码            | **直接执行机器码**           | .exe 或 .out 可执行文件 | 操作系统原生运行              |
| **Java**   | 源码 .java → 编译器 → 字节码 .class | **JVM 解释 + JIT 编译执行** | 字节码 .class / .jar | 依赖 JVM                |
| **Python** | 源码 .py → 解释器                | **逐行解释（或字节码）执行**      | .pyc（字节码，可选）      | Python 解释器（如 CPython） |
# Python 是怎么让机器运行的

**一句话解释**
> Python 程序是由 **解释器逐行读取并执行**的，底层会将代码转成 **字节码**，然后由 **虚拟机**（通常是 CPython）逐条翻译执行。

```sh
你写的 Python 源码 (.py 文件)
        ↓
词法分析 + 语法解析
        ↓
编译成字节码（.pyc 文件） → 放入 __pycache__ 目录
        ↓
解释器（Python 虚拟机）逐条执行字节码 → 转成机器指令 → 执行
```

Python 会：

• 扫描代码，进行**词法/语法分析**
• 编译为一种中间形式：**字节码（bytecode）**
• 这不是机器码，但更接近 CPU 能理解的指令
• 存在 .pyc 文件中（一般保存在 __pycache__）

```shell
print("Hello")  → 变成类似  LOAD_NAME, LOAD_CONST, CALL_FUNCTION 等字节码
```

**解释器执行字节码**
CPython 内部有个“**虚拟机**”，逐条解释这些字节码，并调用对应的 C 函数。
比如：
```python
print("Hello")
```
→ 字节码 CALL_FUNCTION
→ 实际调用底层的 PyObject_Print() 函数
→ 最终输出到控制台

**Python 并不会直接生成机器码？**
**是的**，标准 CPython 并不会直接编译为机器码，而是：
• **字节码解释执行（慢但灵活）**
• 不需要链接、编译等过程，**开发效率极高**


## 和Java对比
**1. 字节码的目标不同**

• **Java 字节码**：
• 更接近真实 CPU 指令集（低级）
• 为了运行在高性能虚拟机（JVM）上
• 强类型、结构严谨、JIT 可优化

• **Python 字节码**（CPython）：
• 更高级，更贴近语义层
• 为了解释器易用、动态性强
• 本质是给解释器用的，不追求极致性能

**2. 执行方式不同：解释 vs JIT 编译**

| **特性** | **Java JVM**   | **Python CPython** |
| ------ | -------------- | ------------------ |
| 热点代码   | 检测后编译为机器码（JIT） | 一直解释执行，无优化         |
| 性能表现   | 程序跑久了越快（优化后）   | 程序多次运行仍然偏慢         |
| 执行单元   | JIT 编译整段方法     | 按字节码逐条解释           |
**3. 类型系统差异**
• **Java 是静态类型语言**
编译阶段类型已知 → 更容易编译为高效字节码 → 更适合 JIT 优化
• **Python 是动态类型语言**
类型运行时才确定 → 解释器每一步都要动态判断 → 不适合提前编译优化

 **4. 启动方式和生态不同**
 
| **对比点** | **Java**           | **Python**             |
| ------- | ------------------ | ---------------------- |
| 启动方式    | java Hello（需要 JVM） | python hello.py（解释器执行） |
| 文件结构    | .java → .class     | .py → .pyc（自动生成）       |
| 运行环境    | JVM 负责加载/执行字节码     | Python 解释器负责编译+执行      |


5.**执行流程：**

| **语言** | **编译命令**                          | **执行方式**            |
| ------ | --------------------------------- | ------------------- |
| Java   | javac Hello.java → 生成 Hello.class | JVM 加载字节码并执行（可能JIT） |
| Python | 无需手动编译                            | 解释器自动编译为 .pyc，再解释执行 |
# 刚刚说到JVM帮助Java实现跨平台，那Jvm除了解释字节码之外还有什么其他能力吗

**类加载机制（ClassLoader）**
• 按需加载 .class 字节码
• 支持多层类加载器（Bootstrap → Ext → App → 自定义）
• 可以实现 **插件化、热部署、隔离加载**
📌 举例：Spring Boot 使用自定义类加载器加载 Jar 包和配置，实现模块热插拔。

 **内存管理模型**
JVM 管理多个内存区域：

|**区域**|**作用**|
|---|---|
|程序计数器|线程私有，记录当前执行字节码位置|
|Java 虚拟机栈|存储局部变量、操作数栈、方法调用帧|
|本地方法栈|支持 JNI（调用 C/C++）|
|堆（Heap）|所有对象实例分配地，GC 主要作用区|
|方法区（元空间）|存储类信息、常量池、静态变量等|
**垃圾回收（GC）机制**
JVM 提供多种 GC 策略：

|**GC 名称**|**特点**|
|---|---|
|Serial GC|单线程，适合小堆|
|Parallel GC|多线程，适合吞吐优先场景|
|CMS（已废弃）|并发低延迟，适合响应时间敏感系统|
|G1 GC|平衡吞吐与低延迟，适合大堆|
|ZGC / Shenandoah|超低延迟 GC，面向大内存新一代应用|
# 垃圾回收器是怎么回收垃圾的

## 对象有限在Eden区分配
大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。下面我们来进行实际测试一下。
## 长期存活的对象将进入老年区

既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。

大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。

对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中


## 回收过程
1. Eden 满了，触发 Minor GC（只清理年轻代）
2. 使用 **复制算法**：
	• 从 Eden 复制存活对象到 Survivor 区
	• Survivor 区不够就复制到老年代
3. 老年代满了，才触发 Major GC 或 Full GC

## 主要算法

| **算法名称**              | **简介**                  | **是否常用**     |
| --------------------- | ----------------------- | ------------ |
| 引用计数法                 | 对象被引用就加计数，引用断了就回收       | ❌（容易循环引用问题）  |
| **可达性分析（根搜索）**        | 从 GC Roots 出发搜索对象图      | ✅ Java 的主流做法 |
| 标记-清除（Mark-Sweep）     | 标记存活对象 → 清除无用对象         | ✅            |
| 复制算法（Copying）         | 将存活对象复制到新区域             | ✅ 年轻代用得多     |
| 标记-压缩（Mark-Compact）   | 标记后整理内存碎片               | ✅ 老年代常用      |
| 分代收集（Generational GC） | 按对象年龄分区（年轻代/老年代）用不同算法处理 | ✅✅✅ 最核心机制    |


## 引用类型有哪些？有什么区别？

引用类型主要分为强软弱虚四种：

- ﻿﻿强引用指的就是代码中普遍存在的赋值方式，比如A a= newA（）这种。强引用关联的对象，永远不会被GC回收。
- ﻿软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。
- ﻿弱引用可以用WeakReference来描述，他的强度比软引用更低一点，弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。
- ﻿﻿虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和  
    ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。


# 幸存区的算法是用复制还是清理算法，为什么
复制算法，标记-清除算法

# 垃圾回收主要是在哪回收，内存的其他块有什么作用呢
在堆回收

![](https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png)
## 程序计数器
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

## Java虚拟机栈
其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。

方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。

栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。
![](https://oss.javaguide.cn/github/javaguide/java/jvm/stack-area.png)
**局部变量表** 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）

**操作数栈** 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。

**动态链接** 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 **动态连接** 。


## 本地方法栈
和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

## 方法区
存储虚拟机加载的类型信息，常量，静态变量。即使编译器编译后的代码缓存的数据
当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

### 运行时常量池
方法区的一部分：Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。


# 直接内存
JDK1.4 中新加入的 **NIO（Non-Blocking I/O，也被称为 New I/O）**，引入了一种基于**通道（Channel）**与**缓存区（Buffer）**的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。


# 堆
Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**
## 字符常量词
**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。


# 虚拟机栈出栈入栈的是一个是什么
看上面
# Java的基础数据类型


# Int的最大值和最小值分别是多少

# 为什么会这样

# 浮点数是底层实现是什么，为什么会出现精度不一样的情况



# 浏览器输入一个网址到显示页面，会发生什么

![[银河智学#浏览器输入一个地址到这个页面渲染，中间大概经历什么过程]]]






# TCP怎么保证可靠传输/ 他的发包是一个个发的吗？
滑动窗口机制：
操作系统维护一个缓存空间
发送方：
- ﻿﻿#1 是已发送并收到 ACK确认的数据：1~31字节
- ﻿﻿#2 是已发送但未收到 ACK确认的数据：32~45 字节
- ﻿﻿#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节
- ﻿﻿#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg?)


接收方滑动窗口
- ﻿﻿#1+#2 是已成功接收并确认的数据（等待应用进程读取）；
- ﻿﻿#3 是未收到数据但可以接收的数据；
- ﻿﻿#4 未收到数据并不可以接收的数据；
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg)


# TCP还有一些机制保证传输的高效，有哪些机制

## 重传
### 超时重传
重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。

### 快速重传
在上图，发送方发出了1，2，3，4，5份数据：

- ﻿﻿第一份 Seql 先送到了，于是就 Ack 回2；
- ﻿结果 Seq2因为某些原因没收到，Seq3到达了，于是还是 Ack 回2；
- ﻿后面的 Seq4 和 Seq5都到了，但还是 Ack 回 2，因为 Seq2还是没有收到；
- ﻿发送端收到了三个 Ack =2的确认，知道了 Seq2还没有收到，就会在定时器过期之前，重传丢失的Seq2。
- ﻿最后，收到了 Seq2，此时因为 Seq3，Seq4， Seq5 都收到了，于是 Ack 回6。

所以，快速重传的工作方式是当收到三个相同的ACK报文时，会在定时器过期之前，重传丢失的报文段。

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。

### SACK

还有一种实现重传机制的方式叫：SACK（Selective Acknowledgment），选择性确认。

这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传去失的数据。

### Duplicate SACK

Duplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。



## 流量控制

回一起收缩窗口调整流量

TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。

TCP是如何解决窗口关闭时，潜在的死锁现象呢？

为了解决这个问题，TCP为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。

如果持续计时器超时，就会发送窗口探测（Window probe）报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。
## 拥塞控制

有了拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。

为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。

拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。

我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min（cwnd, rwnd），也就是拥塞窗口和接收窗口中的最小值。

拥塞窗口 cwnd 变化的规则：

- ﻿只要网络中没有出现拥塞，cwnd 就会增大；
- ﻿但网络中出现了拥塞，cwnd 就减少；  

>那么怎么知道当前网络是否出现了拥基呢？

其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥墨。

### 慢启动
TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？

慢启动的算法记住一个规则就行：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加1。

这里假定拥塞窗口 cwnd 和发送窗口 swnd 相等，下面举个例子：

- ﻿连接建立完成后，一开始初始化 cwnd= 1，表示可以传一个 MSS大小的数据。
- ﻿﻿当收到一个 ACK 确认应答后，cwnd 增加1，于是一次能够发送2个
- ﻿﻿当收到2个的ACK确认应答后，cwnd增加 2，于是就可以比之前多发2个，所以这一次能够发送4 个
- ﻿当这4个的ACK 确认到来的时候，每个确认 cwnd 增加1，4个确认 cwnd 增加 4，于是就可以比之前多发4个，所以这一次能够发送8个。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)



### 拥塞避免算法
前面说道，当拥基窗口 cwnd「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。

一般来说 ssthresh 的大小是 65535字节。

那么进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd。

接上前面的慢启动的栗子，现假定 ssthresh 为8：

•当8个 ACK 应答确认到来时，每个确认增加1/8，8个 ACK 确认 cwnd 一共增加1，于是这一次能够发送9个MSS 大小的数据，变成了线性增长。

拥塞避免算法的变化过程如下图：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)




### 拥塞发生
当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：

- ﻿超时重传
- ﻿﻿快速重传

这两种使用的拥塞发送算法是不同的，接下来分别来说说。
#### 发生超时重传的拥塞发生算法
当发生了「超时重传」，则就会使用拥塞发生算法。

这个时候，ssthresh 和 cwnd 的值会发生变化：
- ﻿﻿ssthresh 设为 cwnd/2，
- ﻿﻿cvnd 重置为 1（是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值1）

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)


#### 发生快速重传的拥塞发生算法

还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。

TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：

- ﻿cwnd = cwnd/2，也就是设置为原来的一半；
- ﻿﻿ssthresh = cwnd ;
- ﻿﻿进入快速恢复算法
#### 快速恢复
快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到3个重复 ACK说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。

正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：

• cund = cwnd/2，也就是设置为原来的一半；
• ssthresh = cwnd ;

然后，进入快速恢复算法如下：

- ﻿﻿拥塞窗口 cwnd = ssthresh + 3（3的意思是确认有3个数据包被收到了）；
- ﻿﻿重传丟失的数据包；
- ﻿﻿如果再收到重复的 ACK，那么 cwnd 增加 1；
- ﻿﻿如果收到新数据的ACK后，把cwnd设置为第一步中的ssthresh 的值，原因是该 ACK确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

# 和对方服务器建连，除了IP地址还有啥
端口号

# https和http的区别，怎么加密的
HTTP 田于是明文传输，所以安全上存在以下三个风险：
- ﻿窃听风险，比如通信链路上可以获取通信内容，用户号容易没。
- ﻿﻿篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
- ﻿冒充风险，比如冒充淘宝网站，用户钱容易没。

HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：
- ﻿﻿在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。
- ﻿﻿在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。

采用「混合加密」的方式的原因：
- ﻿对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- ﻿非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

**1. 建立连接时：使用非对称加密传递“会话密钥”（也叫对称密钥）**
• 客户端（如浏览器）访问服务器时，会获取服务器的 **公钥**（通过证书传过来）。
• 客户端生成一个**临时的会话密钥**（就是用来进行对称加密的数据加密密钥）。
• 客户端使用服务器的**公钥**加密这个会话密钥，并发送给服务器。
• 服务器用自己的**私钥**解密，获得客户端生成的会话密钥。

**2. 建立连接后：使用对称加密进行通信**
• 客户端和服务器都拥有相同的“会话密钥”。
• 后续的数据传输全部使用**对称加密**来处理，既快速又节省资源。
• 因为对称密钥之前通过非对称加密安全传递，所以整体通信仍然是安全的。


## 对称加密和非对称加密
**🔐 对称加密（Symmetric Encryption）**
**定义**：加密和解密使用的是**同一个密钥**。发送方和接收方都必须事先共享这个密钥。

**特点**：
• 加密解密速度快，适合大数据量传输。
• 密钥分发困难：必须安全地将密钥发送给对方，否则容易被窃取。

**举例**：
• 小红用密钥 abc123 加密了一个消息发给小明，小明用同一个密钥 abc123 解密。
• 如果别人截获了密钥 abc123，他们也能解密信息。


**🔐 非对称加密（Asymmetric Encryption）**
**定义**：使用**一对密钥**：公钥（public key）和私钥（private key）。
• 公钥用于加密；
• 私钥用于解密（反之亦可，取决于用途）。

非对称加密算法来解决，共有两个密钥：
- ﻿﻿一个是公钥，这个是可以公开给所有人的；
- ﻿﻿一个是私钥，这个必须由本人管理，不可泄路。
- 
这两个密钥可以双向加解密的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。

==流程的不同，意味着目的也不相同：==
- ﻿公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
- ﻿私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。


**特点**：
• 更安全，适合身份验证、密钥交换。
• 加密解密速度慢，不适合大数据量。
• 公钥可以公开，私钥必须保密。

**举例**：
• 小红有一对密钥：公钥和私钥。
• 她把公钥发给小明。
• 小明用公钥加密一段消息发给小红。
• 小红用自己的私钥解密。
• 即使其他人拿到公钥，也无法解密消息。




## 建立连接前
**哈希算法保证内容不别篡改**
为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。

对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。

那么，在计算机里会用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容。


**非对称加密（服务端私钥加密，客户端公钥解密）保证内容是来自服务端的**
通过哈希算法可以确保内容不会被篡改，但是并不能保证「内容＋哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明。

私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。


**通过中间者，保证公钥的正确性**。
为防止公认的公钥被别人替换，这样别人就可以发自己私钥的内容给到客户端。

首先服务器回把自己 公钥发给CA，CA把用自己的私钥加密服务器的公钥（数字签名），然后CA把公钥+服务器信息+数字签名 打包成数字证书，给回服务器。

之后服务器发送消息给客户端的时候，不仅会对消息用自己私钥数字签名，还会把数字证书一起发送。

客户端器预先导入了CA的公钥，用CA的公钥解密，获取到服务器的公钥，就可以验证消息的准确性，并且可以用服务器的公钥加密发送给服务器信息

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)




## 建立连接后使用对称加密进行通信


# 双重检查锁单例/询问两个if分别用来干嘛

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public  static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```
# [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
