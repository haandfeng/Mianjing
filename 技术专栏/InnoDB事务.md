


首先要知道一共三种读的问题

- ﻿脏读：读到其他事务未提交的数据；
- ﻿不可重复读：前后读取的数据不一致；
- ﻿幻读：前后读取的记录数量不一致。


SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：
- ﻿读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；
- ﻿读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；
- ﻿可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；
- ﻿串行化（serializable）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；


幻读这么解决
MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇文章已），解决的方案有两种：
- ﻿针对快照读（普通 select语句），是通过MVCC方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。

- ﻿针对当前读（select.. for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select.. for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-keylock锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。


![](https://cdn.xiaolincoding.com//mysql/other/d5de450e901ed926d0b5278c8b65b9fe.png)

在不同隔离级别下，事务 A执行过程中查询到的余额可能会不同：

- ﻿在「读未提交」隔离级别下，事务B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务A看见了，于是事务A 中余额 V1 查询的值是 200万，余额 V2、V3 自然也是200万了；
- ﻿在「读提交」隔离级别下，事务B修改余额后，因为没有提交事务，所以事务 A 中余额V1 的值还是100万，等事务 B提交完后，最新的余额数据才能被事务A 看见，因此额 V2、V3都是200万；
- 在「可重复读」隔离级别下，事务A 只能看见启动事务时的数据，所以余额V1、余额V2的值都是100万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额V3 的值是200万；
- 在「串行化」隔离级别下，事务B 在执行将余额100 万修改为 200万时，由于此前事务A执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从A 的角度看，余额 V1、V2的值是100万，余额 V3的值是200万。

这四种隔离级别具体是如何实现的呢？

- ﻿对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
- ﻿对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
- ﻿对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。==「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read  View.==


注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：

- ﻿第一种：begin/start transaction 命令；
- ﻿﻿第二种：start transaction with consistent snapshot 命令；

这两种开启事务的命令，事务的启动时机是不同的：

- ﻿执行了 begin/start transaction命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条select 语句，才是事务真正启动的时机；
- ﻿执行了 start transaction with consistent snapshot 命令，就会马上启动事务。


## Read View 在 MVCC 里如何工作的？

Read View 四个字段

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png)


Read View 有四个重要的子段：

- ﻿﻿creator_trx_id：指的是创建该 Read View 的事务的事务id。
- ﻿﻿m_ids：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务id列表，注意是一个列表，“活跃事务"指的就是，启动了但还没提交的事务。
- ﻿min_trx_id：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务id 最小的事务，也就是m_ids 的最小值。
- ﻿max_trx_id：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的id 值，也就是全局事务中最大的事务id 值+1；

知道了 Read View 的字段，我们还需要了解聚簇索引记录中的两个隐藏列。

- ﻿trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务id 记录在trx_id 隐藏列里；
- ﻿﻿roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。



- ﻿﻿如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View  前已经提交的事务生成的，所以该版本的记录对当前事务可见。
- ﻿﻿如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 ReadView 后才启动的事务生成的，所以该版本的记录对当前事务不可见。
- ﻿﻿如果记录的trx_id 值在 Read View的 min_trx_id 和 max_trx_id 之间，需要判断trx_id 是否在m_ids 列表中：
- ﻿如果记录的trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。
- ﻿如果记录的trx_id 不在m_ids 列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。

## 可重复读的实现
在开启事务之后，第一条Select语句生成快照，然后根据上面的规则，匹配能否读到数据。
主要的匹配逻辑：    是否比当前活跃事务的最小值小，小说明已经提交了，旧版本数据，可以读。
                如果比当前活跃数据最小值大，但比最大值小。那就看在不在活跃事务列表里，如果不在，说明已经提交，也可以读。
	             不然都不能读


## 读提交的实现

一样的逻辑，但是他是在每一条Select语句都会生成快照


# 可重复读如何解决幻读

- ﻿针对快照读（普通 select 语句），是通过 MVCC方式解决了幻读，因为可重复读隔离级别下，事务执，行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。

- ﻿针对当前读（select.. for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select.. for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-keylock锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

但都不能完全解决，因为只要update/其他当前读语句出现，他就会读取最新的数据库记录。发生幻读。并且update了之后，对应那行的trx_id就会变成当前事务的id了，就可以被读到了。