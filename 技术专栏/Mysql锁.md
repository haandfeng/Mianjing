
**全局锁**：用于做全库备份。（可重复读的时候，因为MVCC的支持，可以对数据库进行修改操作，不然就只能读）

# 表级锁
**表锁**：表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。举个例子，如果在某个线程A 中执行 lock tables t1 read,t2 write；这个语句，则其他线程写t、读写t2的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读t1、读写t2的操作。连写t1 都不允许，自然也不能访问其他表。

**元数据锁**：我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：
- ﻿对一张表进行 CRUD 操作时，加的是 MDL 读锁；
- ﻿﻿对一张表做结构变更操作的时候，加的是 MDL 写锁；

当有线程在执行 select 语句（加MDL 读锁）的期间，如果有其他线程要更改该表的结构（申请MDL 写锁），那么将会被阻塞，直到执行完 select 语句（释放 MDL 读锁）。

反之，当有线程对表结构进行变更（加 MDL写锁）的期间，如果有其他线程执行了 CRUD 操作（申请MDL 读锁），那么就会被阻塞，直到表结构变更完成（释放 MDL写锁）。



**意向锁**：
- ﻿﻿在使用InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
- ﻿﻿在使用InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；

也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。
而普通的 select 是不会加行级锁的，普通的 select 语句是利用MVCC 实现一致性读，是无锁的。

意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁 （lock tables..read）和独占表锁 （lock tables..write）发生冲突。

表锁和行锁是满足读读共享、读写互斥、写写互斥的。

==如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。==

那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，==这样就不用去遍历表里的记录。所以，意向锁的目的是为了快速判断表里是否有记录被加锁。==


**AUTO-INC锁**：

表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。

之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过AUTO-INC 锁实现的。

==AUTO-INC锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。在插入数据时，会加一个表级别的 AUTO-INC锁，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC锁释放掉。==

那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。

但是，AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。因此，在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。

一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。

==使用轻量级锁，主从复制的时候会存在主从不一致的情况，要解决这问题，binlog日志格式要设置为 row，这样在 binlog里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。==

# 行级锁
