
[参考](https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd) 还有[黑马](https://www.bilibili.com/video/BV1cr4y1671t/?p=38&vd_source=320ecdd8d14979567afe9d21045ad392)

# 但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：
因为操作分为两步，那么就很有可能存在「第一步成功、第二步失败」的情况发生
1. 先更新缓存，后更新数据库
    
2. 先更新数据库，后更新缓存
	有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：
	1. 线程 A 更新数据库（X = 1）
	2. 线程 B 更新数据库（X = 2）
	3. 线程 B 更新缓存（X = 2）
	4. 线程 A 更新缓存（X = 1）
	最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。
	
	也就是说，A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。

>同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。

除此之外，我们从「缓存利用率」的角度来评估这个方案，也是不太推荐的。

这是因为每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。

而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中。

==由此可见，这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。==

所以此时我们需要考虑另外一种方案：**删除缓存**。

# 删除缓存
问题都出现在用数据库的旧的值写入了缓存，导致了不一致

**1) 先删除缓存，后更新数据库**
==删了缓存，后来不及更新数据库，用数据库旧值写了缓存==
如果有 2 个线程要并发「读写」数据，可能会发生以下场景：

1. 线程 A 要更新 X = 2（原值 X = 1）
    
2. 线程 A 先删除缓存
    
3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）
    
4. 线程 A 将新值写入数据库（X = 2）
    
5. 线程 B 将旧值写入缓存（X = 1）
    

最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。

可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。


但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：**缓存延迟双删策略**。

按照延时双删策略，这 2 个问题的解决方案是这样的：

**解决第一个问题**：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。


**2) 先更新数据库，后删除缓存**
==更新了数据库前，缓存不存在，读取数据库的值，然后再更新数据库，删缓存，数据库旧值再写缓存，导致不一致==
依旧是 2 个线程并发「读写」数据：

1. 缓存中 X 不存在（数据库 X = 1）
    
2. 线程 A 读取数据库，得到旧值（X = 1）
    
3. 线程 B 更新数据库（X = 2)
    
4. 线程 B 删除缓存
    
5. 线程 A 将旧值写入缓存（X = 1）
    

最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。

这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？

其实概率「很低」，这是因为它必须满足 3 个条件：

1. 缓存刚好已失效
    
2. 读请求 + 写请求并发
    
3. 更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）
    

仔细想一下，条件 3 发生的概率其实是非常低的。

因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。

这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。

所以，我们应该采用这种方案，来操作数据库和缓存。



**解决第二个问题**：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。




## 一些总结

1、想要提高应用的性能，可以引入「缓存」来解决

2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」

3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生

4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案

5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性。 ==除了重试，黑马点评也给出了一个新的方案，用事务保证。==

6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率


# 回答问题

最后要对比出这几种方案。  
- 先更新缓存，后更新数据库  
- 先更新数据库，后更新缓存  
- 先删除缓存，后更新数据库（延时双删的场景）  
- 先更新数据库，后删除缓存  
- 订阅数据库binlog  
- 消息队列  

若有收获，就点个赞吧