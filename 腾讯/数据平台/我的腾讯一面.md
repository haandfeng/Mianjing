



# 怎么保证系统升级的时候数据和系统的稳定性

主要是在测试环境进行操作，在测试环境处理好了，才上线服务。
并且在导入数据之后，我会进行系统的数据比对，保证数据的稳定性。


# 你提到“优化查询和插入”，是怎么优化的？怎么分析的？
当时主要的查询效率低下的问题是Join的时候因为采用Select* 的sql语句导致的。

我在分析查询性能瓶颈时，首先使用了 EXPLAIN ANALYZE 工具，发现虽然语句命中了索引，但由于 SELECT * 取出了所有字段，包括一些大字段（如 JSON、text 类型字段），导致数据库在执行 Index Scan 后还要额外进行回表操作（即访问堆表取完整行数据），整体响应时间非常慢。

![[银河智学#实习怎么优化了数据表的查询效率]]


# 比如说我数据库里有一部分数据，然后你这边再做插入，然后有的就去更新这种怎么保证效率，

**推荐的高效方案：批量 UPSERT**

如果你用的是 MySQL（8.0+），建议用：
**🔹 INSERT ... ON DUPLICATE KEY UPDATE**
```sql
INSERT INTO product (id, name, price)
VALUES
  (1, 'Apple', 5.0),
  (2, 'Banana', 3.0),
  (3, 'Orange', 4.0)
ON DUPLICATE KEY UPDATE
  name = VALUES(name),
  price = VALUES(price);
```

 **特点：**
• **一次性写入全部数据**
• **自动判断更新/插入**
• **不需要你先查询数据库有没有**
• 速度极快：适合**中等或大批量数据同步**


# 你刚才提到了你优化的过程中有加了索引对吧？对。你用的数据库里面它分哪些类的索引呢，区别是什么


|**索引类型**|**简介**|**适用场景**|
|---|---|---|
|**主键索引（Primary Key）**|表的唯一标识，默认是聚簇索引（InnoDB）|唯一标识记录，用于主键查询|
|**唯一索引（Unique Index）**|保证字段唯一性|如用户名、邮箱等不允许重复的字段|
|**普通索引（Index）**|不唯一的索引|高频查询字段或连接字段|
|**联合索引（Composite Index）**|多字段组成的索引，顺序很重要|组合查询、排序等场景|
|**覆盖索引（Covering Index）**|查询所需字段都在索引中，无需回表|提高查询效率|
|**全文索引（Fulltext）**|用于文本搜索（MyISAM, InnoDB部分支持）|如模糊搜索、搜索引擎类场景|
|**空间索引（Spatial）**|针对地理位置数据，基于 R-Tree|GIS 应用场景|


• 普通索引是**非聚簇索引**，只保存索引键 + 主键值（指针），需要回表；

• 覆盖索引是结构上依赖普通索引，但只要 select 的字段都在索引中，就不需要访问主表，能显著提高查询效率；

• 联合索引涉及**最左匹配原则**，查询条件要从左向右连续命中才能使用索引；

• 唯一索引功能上类似主键索引，但不是聚簇结构；

• 空间索引和全文索引属于特殊用途索引，用得不多，但在特定领域很重要。


## PgSql中
| **索引类型**                            | **简介**             | **适用场景**                    | **优缺点**               |
| ----------------------------------- | ------------------ | --------------------------- | --------------------- |
| **B-Tree**（默认）                      | 默认索引结构，基于有序树       | 等值查询、范围查询（=, <, >, BETWEEN） | 查询效率高，通用性强；不适合全文、数组等  |
| **Hash**                            | 哈希结构，只支持等值查询       | 高性能等值查找（=）                  | 更新代价高、写性能差；使用较少       |
| **GIN**（Generalized Inverted Index） | 倒排索引               | 多值字段（如数组）、全文搜索（tsvector）    | 查询非常快，但构建和更新成本高       |
| **GiST**（Generalized Search Tree）   | 通用搜索树，支持模糊匹配和空间数据  | 范围匹配、模糊查询、地理空间数据（PostGIS）   | 构建速度快，查询比 GIN 慢，但更新快  |
| **BRIN**（Block Range Index）         | 基于块范围的索引，记录数据区间信息  | 超大表（如日志表）的顺序字段（时间戳）         | 索引非常小，构建快，适合顺序数据      |
| **SP-GiST**（Space-partitioned GiST） | 用于非平衡数据结构，如八叉树、前缀树 | 特殊场景，如字符串前缀、IP段匹配等          | 特定用途，开发者较少用到          |
| **Bloom**（扩展模块）                     | 位图布隆过滤器索引          | 多字段等值查询，适合大表宽表              | 近似查询，可能有误报，不能完全替代精确匹配 |



# 主键索引与非主键索引的区别？

| **类别**       | **主键索引（Primary Key Index）** | **非主键索引（二级索引 / Secondary Index）** |
| ------------ | --------------------------- | --------------------------------- |
| 是否唯一         | ✅ 必须唯一                      | ❌ 可以重复（除非设成 Unique Index）         |
| 是否允许为空       | ❌ 不允许为 NULL                 | ✅ 可以为 NULL                        |
| 是否自动创建       | ✅ 创建主键时自动建立                 | ❌ 需手动指定                           |
| 是否作为表的默认排序结构 | ✅ 是                         | ❌ 否                               |
• **主键索引是聚簇索引（Clustered Index）**

数据记录**实际存储在主键索引的叶子节点上**，即：

> 主键索引 = 索引结构 + 实际数据行

• **非主键索引是非聚簇索引（Secondary Index）**

非主键索引的叶子节点中只保存**索引字段 + 主键值**，真正数据还得**通过主键回表查一次**。


# 如果不建主键，他会这么存呢

|**情况**|**InnoDB 会怎么处理？**|
|---|---|
|你定义了主键|直接使用该主键做聚簇索引（最理想）|
|没有主键，但有 NOT NULL 且 UNIQUE 的列|会选第一个符合条件的唯一键作为聚簇索引|
|没有任何主键或唯一键|会**自动生成一个隐藏的 row_id 列（6字节）**，作为聚簇索引 key，用于定位数据行|



# 你提到的 RPC 框架是怎么实现的？为什么做这个项目？
自己扯蛋

# 自定义TCP协议里面有什么字段，分了几层

整个协议由两层组成：
**1）消息头（Header）：固定长度，负责描述“如何解析”**
**2）消息体（Body）：变长，携带实际业务数据（请求参数 / 响应结果）**

| **字段名**    | **类型** | **字节数** | **含义**                                 |
| ---------- | ------ | ------- | -------------------------------------- |
| magic      | byte   | 1       | 魔数，用于快速识别是否合法协议（如 0x13），防止非法请求或协议混乱    |
| version    | byte   | 1       | 协议版本号，便于将来升级兼容                         |
| serializer | byte   | 1       | 序列化方式标识（如 0=JSON, 1=Kryo），用于动态选择反序列化策略 |
| type       | byte   | 1       | 消息类型（如 0=请求，1=响应，2=心跳等），支持多类型交互        |
| status     | byte   | 1       | 请求处理状态码（如 0=OK，1=异常），主要在响应中用           |
| requestId  | long   | 8       | 请求唯一 ID，用于客户端异步调用与响应结果匹配               |
| bodyLength | int    | 4       | 消息体长度（单位：字节），用于解码器做粘包拆包                |

• **为什么要用魔数？**

> 用于快速识别协议起始位置，防止接收到非本协议数据时出错（提升安全性和容错性）；

• **为什么要有 requestId？**

> 因为客户端可能同时发起多个请求，requestId 是客户端与服务端响应匹配的依据；

• **如何防止粘包拆包？**

> 利用 bodyLength 字段配合 Netty 的 LengthFieldBasedFrameDecoder 实现分包，确保接收端读到完整消息；

# 描述一下怎么请求，客户端怎么返回到请求端

1. 首先通过动态代理机制，构造请求
	封装请求信息->请求服务名字，方法名字，参数，请求版本号
	调用注册中心，转入请求服务名字，，获取请求的IP地址和端口号
	负载均衡，选择一个服务地址
	把请求传入重试机制，发起请求（VertxTcpClient.doRequest）
	catch捕获异常，尝试容错机制
2. VertxTcpClient.doRequest发起请求
	VertxTcpClient会构造全局映射表消息等待池（requestID，CompletableFuture\<RpcResponse>）
	根据IP和端口号发起连接
	连接成功，构造自定义信息头部
	使用雪花算法生成唯一requestID
	把异步任务放到消息等待池
	构建处理响应逻辑->解码响应数据，根据解码结果，获取requestID，把返回到异步任务重
	get阻塞获取结果
3. TcpServerHandler处理请求
	 获取请求，解码
	 通过解码，获取要请求的服务名字
	 调用本地注册中心（服务提供者启动后就注册了），获取Class类对象
	 获取要调用的方法名和参数类型，构造方法
	 创建对象，传入对象，传入参数值，调用方法
	 封装返回结果（类型和值）
	 发送响应

# 多个请求和多个响应，你是怎么做对应的
服务消费者会构造一个全局映射表消息等待池（requestID，CompletableFuture\<RpcResponse>），里面有用雪花算法生成的全局唯一requstID，还有异步任务CompletableFuture

# 怎么获取请求地址的

![[蚂蚁一面#项目里的服务发现和服务注册是怎么做的]]

# 怎么控制服务的新老版本调用
1. 如果IP和端口一样，在请求体加多一个一个版本号字段，调用不同的版本号
2. 如果IP和端口不一样了，在seviceInfo（etcd存的value里面）加多一个服务的版本号信息，用来对应不同的本本

# 如何设计容错机制与负载均衡策略？
## 容错

1. Fail-Over 故障转移：一次调用失败后，切换一个其他节点再次进行调用，也算是一种重试。
2. Fail-Back 失败自动恢复：系统的某个功能出现调用失败或错误时，通过其他的方法，恢复该功能的正常。可以理解为降级，比如重试、调用其他服务等。==(改变Proxy)==
3. Fail-Safe 静默处理：系统出现部分非重要功能的异常时，直接忽略掉，不做任何处理，就像错误没有发生过一样。
4. Fail-Fast 快速失败：系统出现调用错误时，立刻报错，交给外层调用方处理。

### 扩展：熔断和限流怎么做

#### 限流
**✅ 一、限流（Rate Limiting）：防止系统被“压死”**
**📌 是什么？**

限流是指对**请求频率或并发数做限制**，控制进入系统的流量，避免服务过载。

**📦 常用方式：**

| **限流算法**               | **原理**             | **特点**          |
| ---------------------- | ------------------ | --------------- |
| 令牌桶（Token Bucket） ✅ 推荐 | 定时生成令牌，请求拿到令牌才能通过  | 支持突发流量          |
| 漏桶（Leaky Bucket）       | 固定速率处理请求，超出部分排队或丢弃 | 控制平均速率，抹平流量峰值   |
| 固定窗口 / 滑动窗口            | 每秒最多允许 N 次请求       | 实现简单，但时间窗口边界不精准 |

#### 熔断

**📌 是什么？**
熔断是指当某个服务出现异常或响应慢时，**自动中断后续请求**，给出快速失败或降级响应，**避免整个系统被拖垮**。

| **状态**        | **说明**              |
| ------------- | ------------------- |
| Closed（闭合）    | 一切正常，允许请求           |
| Open（打开）      | 请求失败率超过阈值，直接拒绝      |
| Half-Open（半开） | 过一段时间后尝试恢复，允许部分请求试探 |


## 负载均衡

1）轮询（Round Robin）：按照循环的顺序将请求分配给每个服务器，适用于各服务器性能相近的情况。

2）随机（Random）：随机选择一个服务器来处理请求，适用于服务器性能相近且负载均匀的情况。

3）加权轮询（Weighted Round Robin）：根据服务器的性能或权重分配请求，性能更好的服务器会获得更多的请求，适用于服务器性能不均的情况。

4）加权随机（Weighted Random）：根据服务器的权重随机选择一个服务器处理请求，适用于服务器性能不均的情况。

5）最小连接数（Least Connections）：选择当前连接数最少的服务器来处理请求，适用于长连接场景。

6）IP Hash：根据客户端 IP 地址的哈希值选择服务器处理请求，确保同一客户端的请求始终被分配到同一台服务器上，适用于需要保持会话一致性的场景。

7)还可以使用一致性 Hash 算法，解决了节点下线和倾斜问题。
![[蚂蚁一面#负载均衡是怎么做的]]


# TCP怎么保证可靠传输

| **机制**      | **作用**             | **关键点**            |
| ----------- | ------------------ | ------------------ |
| 1️⃣ 三次握手    | 建立可靠连接             | 双方确认收发能力、初始化序号     |
| 2️⃣ 序列号与确认号 | 保证数据**有序、无重复、无丢失** | 每个字节都有序号，ACK 确认已收到 |
| 3️⃣ 重传机制    | 避免数据丢失             | 超时重传、快速重传          |
| 4️⃣ 滑动窗口    | 控制发送速率，流量控制        | 接收方告诉发送方窗口大小       |
| 5️⃣ 拥塞控制    | 避免网络过载导致丢包         | 慢启动、拥塞避免、快重传、快恢复   |
| 6️⃣ 四次挥手    | 确保数据全部传完后安全断开      | 双向关闭，防止连接中断丢数据     |


# threadLocal的原理

![[银河智学#为什么用ThreadLocal，ThreadLocal为什么线程隔离]]


# 怎么处理他的内存泄露问题
在项目中，afterCompletion()会调用，然后对内存泄露进行一个处理
# 如果运行时出现了异常，走不到拦截器的afterCompletion函数，怎么处理内容溢出的问题

| **方法**            | **所在接口**           | **调用时机**                                |
| ----------------- | ------------------ | --------------------------------------- |
| postHandle()      | HandlerInterceptor | Controller 执行**成功返回之后**，在视图渲染之前         |
| afterCompletion() | HandlerInterceptor | 整个请求**完成之后**，包括视图渲染之后，**无论是否成功或异常**都被调用 |

好像不会有问题，被诈了？

```sh
    ↓ 请求进入 DispatcherServlet
 → preHandle()
    ↓
 → Controller 方法执行
    ↓
 → postHandle()         ← 如果 Controller 正常返回，调用
    ↓
 → 渲染视图（如 Thymeleaf、JSP 等）
    ↓
 → afterCompletion()    ← 无论有没有异常，都会调用
```


除非是请求中断的情况在prehandle的时候抛出异常

```java
@Override
public boolean preHandle(...) {
    // 这里抛出异常了
    UserHolder.saveUser(user);
    throw new RuntimeException("故意抛异常");
}
```
这种情况用 try...finally 保底：







# Java中你了解哪些锁？各自适用什么场景？

**1️⃣ synchronized（内置锁）**
• 适合简单并发控制，使用最方便
• 不可中断，不支持公平性
• JVM 会自动优化（偏向锁 → 轻量级锁 → 重量级锁）

**适用：**
• 多线程访问同一个方法或代码块时保护共享变量
• 写法简单：synchronized(this)、synchronized method()

**2️⃣ ReentrantLock（可重入显示锁）**
• 可以手动加锁/释放锁
• 支持可中断、公平性、条件变量（await/signal）

**适用：**
• 多线程竞争复杂场景
• 需要实现可重入锁、定时锁、公平锁等需求


**3️⃣ ReentrantReadWriteLock（读写锁）**
• 读可以并发，写是独占的
• 可以显著提升读多写少的性能

**适用：**
• 本地缓存、配置中心、字典表、商品信息查询等

Java中有哪些常用的锁，在什么场景下使用？

Java中的锁是用于管理多线程并发访问共享资源的关键机制。锁可以确保在任意给定时间内只有一个线程可以访问特定的资源，从而避免数据竞争和不一致性。Java提供了多种锁机制，可以分为以下几类：
- ﻿﻿内置锁（synchronized）：Java中的 synchronized 关键字是内置锁机制的基础，可以用于方法或代码块。当一个线程进入synchronized代码块或方法时，它会获取关联对象的锁；当线程离开该代码块或方法时，锁会被释放。如果其他线程尝试获取同一个对象的锁，它们将被阻塞，直到锁被释放。其中，syncronized加锁时有无锁、偏向锁、轻量级锁和重量级锁几个级别。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用偏向锁，以减少锁的开销。轻量级锁使用线程栈上的数据结构，避免了操作系统级别的锁。重量级锁则涉及操作系统级的互斥锁。

- ﻿﻿ReentrantLock: java.util.concurrent. locks.ReentrantLock 是一个显式的锁类，提供了比synchronized 更高级的功能，如可中断的锁等待、定时锁等待、公平锁选项等。ReentrantLock 使用 1ock（）和 unlock（）方法来获取和释放锁。其中，公平锁按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。非公平锁不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿。

- ﻿读写锁（ReadWriteLock）：java.util.concurrent.locks.ReadwriteLock 接口定义了一种锁，允许多个读取者同时访问共享资源，但只允许一个写入者。读写锁通常用于读取远多于写入的情况，以提高并发性。

- ﻿乐观锁和悲观锁：悲观锁（Pessimistic Locking）通常指在访问数据前就锁定资源，假设最坏的情况，即数据很可能被其他线程修改。 synchronized 和 ReentrantLock 都是悲观锁的例子。乐观锁（Optimistic Locking）通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用版本号或时间戳来实现。

- ﻿自旋锁：自旋锁是一种锁机制，线程在等待锁时会持续循环检查锁是否可用，而不是放弃CPU并阻塞。  通常可以使用CAS来实现。这在锁等待时间很短的情况下可以提高性能，但过度自旋会浪费CPU资源。

# Java 出现内存溢出（OOM）时你会怎么排查？

栈溢出：
	1.栈帧过多
	2.栈帧过大

## 常见错误信息
```sh
java.lang.OutOfMemoryError: Java heap space
```
根据具体错误信息，常见的 OOM 类型包括：
• Java heap space：-Xmx调整堆控制内存大小堆内存不足，最常见；
• StackOverflowError： 栈内存溢出     -Xss 控制栈内存大小
• GC overhead limit exceeded：频繁 GC 却回收不了内存；
• PermGen space（JDK 8 前）或 Metaspace（JDK 8+）：类元信息溢出；
• Direct buffer memory：NIO 分配的直接内存溢出；
• unable to create new native thread：线程数超过系统限制；
• OutOfMemoryError: Requested array size exceeds VM limit：数组过大。


## 常见工具
**1. 内存快照分析（Heap Dump）**

• 使用 -XX:+HeapDumpOnOutOfMemoryError 启动参数，在 OOM 时自动生成 .hprof 文件；
• 使用 **MAT（Memory Analyzer Tool）** 或 **VisualVM** 分析：
• 查看 **大对象（Dominator Tree）**；
• 查找是否有对象无法被 GC（内存泄漏）；
• 是否有重复加载的类、缓存未清、线程未销毁等问题。

**2. GC 日志分析**

• 通过 -Xlog:gc* 或 -XX:+PrintGCDetails 记录 GC 情况；
• 检查是否频繁 Full GC，是否存在“内存回收后可用空间仍持续下降”的情况。

  
**3. 运行时监控工具**
• 使用 **jstat** 观察堆内各代内存使用；
• 使用 **jmap** 导出堆或查看 histogram；
• 使用 **jstack** 查看是否有线程死循环或未释放资源。

`jstack  <进程id>`
列出这个进程下面的所有线程
可以用来排查死锁，会显示出死锁


`jps`
产看当前系统中有哪些java进程

`jmap -heap <进程id>`
抓去内存快找信息


`jconsole` 链接进程，查看实时丢 内存使用


`jvisualVM`
可以显示堆快照，查看比较大的对象




## **常见 OOM 原因总结**

• 大量缓存未设置 TTL（如使用 ConcurrentHashMap 缓存用户信息）；
• 线程池创建不当导致过多线程占用内存；
• 代码逻辑中对象未释放（典型如 List 无限增长或线程封闭资源泄漏）；
• 第三方库或框架重复加载类（如动态类加载器未关闭）；
• 图片/大文件加载未关闭流导致堆外泄漏；
• NIO 直接内存用量超限但未触发 GC。


**一、常见 OOM（OutOfMemoryError） 的原因及解决方案**
**1. Java 堆内存溢出（Java heap space）**

**原因**：应用中创建了大量对象，超出了堆内存限制，常见于：
• 大集合无限增长（如 List、Map 未清理）
• 一次性加载大文件、大图片进内存
• 无限制缓存（如本地 LRU 缓存、ThreadLocalMap）
• 长生命周期对象引用短生命周期对象导致无法 GC

**解决方案**：
• 优化代码逻辑，避免集合无上限增长
• 给缓存设置 **容量上限和 TTL**
• 尽量使用流式处理，避免大对象一次性加载
• 提升堆大小（如 -Xmx1g），但注意只是缓解，不是根治

---

**2. GC 过载（GC overhead limit exceeded）**
**原因**：JVM 花了大量时间在 GC 上却只能回收极少内存，说明堆已接近极限，但对象依然无法被回收。  
**解决方案**：
• 优化内存使用结构，分析是否有内存泄漏或过度对象创建
• 增加堆内存大小（-Xmx）
• 调整 GC 策略，比如从 CMS 转为 G1，控制 Full GC 的频率

---

**3. 元空间/永久代溢出（Metaspace 或 JDK8 前的 PermGen space）**

**原因**：应用中频繁加载类（如热部署、动态代理、反射、模板引擎），类元信息占满了元空间。  
**解决方案**：
• 合理设置元空间大小（-XX:MaxMetaspaceSize=256m）
• 使用固定类加载器，避免频繁加载/卸载
• 检查框架插件是否引起 classloader 泄漏（如 Tomcat 热部署）

---

**4. 直接内存溢出（Direct buffer memory）**
**原因**：使用 Netty 或 NIO 时，频繁分配 DirectBuffer 且未及时释放

**解决方案**：
• 显式释放 direct buffer（如使用 Netty 的 release() 方法）
• 设置合适的直接内存大小：-XX:MaxDirectMemorySize
• 使用池化的 ByteBuffer 管理器，避免频繁分配回收



# 启动Java程序的时候有没有配置一下参数
-Xss 控制栈内存大小
-XX:MaxMetaspaceSize 控制元空间大小（默认使用内存）
-Xmx100m -XX: +PrintStringTableStatistics -XX:+PrintGCDetails -verbose: gI

-Xms1024m  # 初始堆大小
-Xmx1024m  # 最大堆大小
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200    # 希望GC最大暂停时间
-XX:InitiatingHeapOccupancyPercent=45  # G1触发GC的阈值
-XX:MetaspaceSize=128m
-XX:MaxMetaspaceSize=256m

-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+PrintGCTimeStamps
-Xloggc:/path/to/gc.log

-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/path/to/dump.hprof


# 算法题

```c++
/**  
     * 1、请写一个key value字符串协议解析的实现，输入key value之间用=分割，kv 对之间用&分割。  
     * 如输入：  
     * 待解析的字符串为：  
     * a=b&c=d&，  
     * 转义符：'\'，  
     * 输出分割符号 ' '     * 输出为：  
     * b d     * 要求尽量解析，保持对异常的兼容如 \&\&&===&\\a=b& 的处理  
     * &&     * <p>     * *每个kv对由指定字符分割，kv之间固定用‘=’ 分割  
     */
```

