电话

# 拷打实习
1. **你在用友网络实习的职责是什么？偏运维还是开发？**
2. **你是怎么做数据同步的？新老系统的数据如何迁移、如何共存？**
3. **数据映射规则怎么配置？数据一致性如何保障？是否是一次性的工作？**
4. **实施过程中遇到的主要困难是什么？如何解决？**
5. **你是如何熟悉新的低代码系统的？有文档或培训吗？**
6. **你在实习中最大的收获是什么？**

😭实习太水了，被质疑了。
# 拷打项目

# 项目里的服务发现和服务注册是怎么做的

1. 新起了一个项目注册类
2. 注册的时候。本地注册器存服务名字和对应的Class对象。和etcd连接，把服务的基本信息写入etcd，key是服务的名字和服务的IP地址端口号，Value包括服务的名字，ip地址，端口号，协议的版本号。并且会把已经注册的服务加入遇到一个set里面，方便heartBeat函数，定时调用，重新注册服务，维持服务生命活动
3. 服务发现：首先看缓存有没有对应的服务信息，有直接返回。如果没有根据服务名字，在ectd里面根据前缀匹配找到服务，找到需要的key之后，把会调用watch监听服务信息的变化。并且根据key获取服务信息，把服务信息存到list集合里面。最后把这个list集合放入ConcurrentHashMap的集合里面，作为Cache。
4. 启动Etcd的事件监听机制，监听Key的内容变化。

# 为什么选用etcd
用Go实现，性能比较高，除了性能之外，Etcd 采用 Raft 一致性算法来保证数据的一致性和可靠性，具有高可用性、强一致，具有完善的数据的监听和通知机制等，完
# 有没有用到springboot把它集成
有的，但我没做。要研究一下了
# ConcurrentHashMap在我的项目里怎么起到线程安全的作用 / 能换成HashMap吗

主要是用来做到并发写Cache，这样可以保证总是Cache的数据是最新的。使有多个线程同时访问注册器，也不会出现数据不一致或者并发访问异常的情况。
多个线程打过来，他们会先看cache有没有，如果没有，就会查etcd，写cache，这个时候，就可以保证cache内的内容一定是最后一次查的内容，防止出现数据的相互覆盖的问题。

并且他的锁的粒度很低，能够保持高性能。

# 负载均衡是怎么做的
做了xxxx负载均衡，通过工厂模式获取负载均衡选择器

一致性哈希（传入请求参数和服务信息列表）
用服务信息列表+随机参数，构造哈希虚拟环。（一个服务信息构造一拜个虚拟节点）
利用请求参数获取哈希值，找到大于等于调用请求 hash 值的虚拟节点，返回。

# 了解过Netty吗
没有。


# 大众点评怎么解决超卖问题

乐观锁，判断获取到的库存是否为0/获得的库存和最终的下单的时候是不是一致，+lua脚本保证原子性


# 如果用户拿到你的优惠券了，然后下单下单又失败了，然后业务要求优惠券要还原，其他人还可以继续抢，在这种情况下应该怎么办？

**✅ （1）下单失败后，发送“回滚消息”到消息队列**

• 在订单模块发现下单失败后，发送一个“回滚库存”的消息；
• 消息体中包含：用户ID、券ID、操作类型、业务时间戳等；
• 异步处理这个消息，执行库存回滚逻辑。

**✅ （2）库存回滚逻辑实现（Redis）**

• 使用 Redis 中的 INCR 命令将优惠券库存 +1；
• 同时从标记“已领取用户”的 Set 中移除该用户ID，允许其或他人再次抢券；
• 整个逻辑用 Lua 脚本封装，确保**原子性**。

**✅ （3）保障幂等性和一致性**
• 每个回滚操作生成唯一操作ID（如订单ID + retry ID）；
• Redis 设置幂等 Key，避免重复归还库存；
• MQ 设置重试机制 + 死信队列保障最终一致性。

```sh
用户抢券 → Redis减库存 → 写入订单MQ → 下单失败
     ↓                              ↓
     Redis标记为已抢券         发送回滚消息 → Redis +1
                               Redis取消已抢券标记
```

 如果是秒杀系统，可以加个“延迟回滚机制
• 可以通过消息队列（如 RocketMQ 的延时消息）或 Redis 的 TTL 机制，在订单超时未支付时自动触发库存回滚；
• 避免用户“秒杀后放弃下单”造成库存占用。



# 场景题：将一个用户的多个交易系统的订单统一展示在一个页面？

订单一秒会更新很多，
讨论了很久，基本都在讨论这这个场景

一开始就直接显示就好了，从数据库获取数据，存到一个list里面。

## 你下单下了非常多的单，但是在一屏页面里，你其实没办法去把所有交易系统里的所有数据都拿出来，这样的话性能会有问题，这个时候的话你说不同交易系统它有不同的发生时间，业务它想按照就是交易的时间来做1个排序，然后每页展示10个，这个时候你怎么在你原来的功能去叠加这个功能

汇总起来，每个数据库查10个，然后排序显示

## 前端拿到你这个10条，它是展示出来了，第二页的时候应该怎么展示，因为你这个方案只能展示出第一页的。本地无法缓存那么多数据

---

**✅ 目标：**

• 有 A/B/C 三个交易系统，订单频繁更新

• 页面按**交易时间**排序展示，**每页展示10条订单**

• **必须分页加载**，且数据是全局有序的（不是拼接）

• 前端无法缓存太多数据，分页控制必须在后端完成

---

**✅ 最终方案：基于多系统游标的全局分页**

**🔧 第一步：定义分页游标结构**

每次分页请求需要携带一个游标，表示“上一次每个系统查到了哪一条”**：

```json
{
  "systemA": {"lastTime": "2025-03-30T11:00:05", "lastId": "A102"},
  "systemB": {"lastTime": "2025-03-30T11:00:03", "lastId": "B056"},
  "systemC": {"lastTime": "2025-03-30T10:59:59", "lastId": "C211"}
}
```

• 这个游标结构保留每个系统当前页的最后一条数据的位置（时间戳 + 唯一ID）

• 第一页时，游标为空，表示“取最新的”

---

**🚀 查询流程**

**✅ 第一次请求（第一页）：**

1. 后端对每个交易系统分别查询：**时间最新的N条订单**（如 N=20）

2. 把所有系统的数据合并后，按交易时间降序排序

3. 返回前10条订单给前端

4. 同时构建并返回游标：记录这10条中，**每个系统取到的最后一条数据的位置**

---

**✅ 第二次请求（下一页）：**
1. 前端带上上次的游标发起分页请求

2. 后端根据游标，对每个系统执行条件查询：

```sql
SELECT * FROM orders
WHERE (time < lastTime) OR (time = lastTime AND id < lastId)
ORDER BY time DESC, id DESC
LIMIT N
```  

3. 每个系统再返回 N 条数据（如 N=20）

4. 后端合并所有数据，按时间降序排序，取前10条作为第二页内容

5. 再次生成新的游标并返回给前端

---

**✅ 技术细节说明**

• 排序时用 (time, id) 做复合主键，确保顺序稳定

• 每页只处理约 N × 3 条数据，性能稳定

• 不依赖缓存，支持任意页翻页（前提是带游标）

---

**✅ 举个例子快速理解**

• 第一页返回的数据中，来自 A 的最后一条是 A102，时间是 11:00:05

• 下一页时，A系统就查：

```sql
WHERE (time < '11:00:05') OR (time = '11:00:05' AND id < 'A102')
```

这样你就能准确接着上一条数据往下查，**不会重复、不会漏单**

---

**✅ 小结（重点）**

|**步骤**|**动作**|
|---|---|
|第一次分页|每个系统查最新N条 → 合并 → 排序 → 返回10条 + 游标|
|后续分页|前端带游标 → 每个系统按游标位置继续查 → 合并 → 排序 → 返回10条 + 新游标|
|排序依据|(time, id)，确保时间一致时仍有稳定顺序|
|避免问题|不用全局时间作为唯一游标，必须记录**每个系统的“本地位置”**|

  

---

这就是完整方案。如果你要做后端实现、接口设计、分页参数示例或者流程图，我也可以直接帮你出。需要的话可以说一声。


## ==只有时间会发生的漏单问题（很重要，看这里就能理解为什么要返回每个系统的最后一条了）==

---

**✅ 修正版漏单示例（清晰准确版）**

  

**🌟 假设：每页展示 5 条数据（为了例子更简明）**

  

我们有 3 个系统：A、B、C

每个系统给出如下订单：

  

**A 系统：**

```
A1 - 10:01:00
A2 - 10:00:59
A3 - 10:00:58
```

**B 系统：**

```
B1 - 10:00:57
B2 - 10:00:56
B3 - 10:00:55
```

**C 系统：**

```
C1 - 10:01:01
C2 - 10:00:54
C3 - 10:00:53
```

  

---

**🧭 第一步：合并排序后的全局前 5 条订单（第一页）**

  

将所有订单按时间降序合并排序如下：

```
C1 - 10:01:01
A1 - 10:01:00
A2 - 10:00:59
A3 - 10:00:58
B1 - 10:00:57   ← 第5条，第一页的最后一条
```

**✅ 记录分页游标为 T = 10:00:57**

  

你现在打算在第二页时用这个时间游标查下一页，即：

```
WHERE time < '10:00:57'
```

  

---

**🧨 第二步：你使用这个游标去查下一页**

  

每个系统查出时间小于 10:00:57 的订单：

• A 系统：无

• B 系统：B2 (10:00:56), B3 (10:00:55)

• C 系统：C2 (10:00:54), C3 (10:00:53)

  

于是你第二页拿到的是：

```
B2 - 10:00:56
B3 - 10:00:55
C2 - 10:00:54
C3 - 10:00:53
```

总共只有 4 条，凑不够5条（这也常见），但更关键的是：

---

**❗❗漏了哪一条？**

  

👉 **你漏掉了 B2（10:00:56）之前的那一条！**

  

等等——**不对！你刚才明明在第一页只展示到了 B1（10:00:57）**，那 B2 的时间是 10:00:56，确实在第二页查到了。

  

但是：

  

**❗现在我们加入一个关键变化：**

  

> **在第一页查出数据到展示之间，B 系统插入了一条新的订单 B_NEW：**

```
B_NEW - 10:00:58
```

也就是说：这条新数据**比你第一页展示的最后一条 B1（10:00:57）时间还大**，**但你没来得及看到它**，因为它插入时你已经把第一页确定下来了。

---

**❌ 那你第二页查的是：**

```
WHERE time < '10:00:57'
```

**B_NEW 的时间是 10:00:58，不符合条件 → 永远查不到！**

---

**✅ 这就是真实的“漏单”场景！**

  

**总结一下发生条件：**

• 第一页你展示到了时间为 10:00:57 的订单

• 在第一页和第二页之间，系统**插入了一条**时间为 10:00:58 的订单（比游标时间新）

• 你第二页查询条件是 WHERE time < '10:00:57'，**所以这条新插入的订单就被跳过了、永远漏掉了！**

---

**✅ 怎么解决这个问题？**

  

你得 **记录每个系统当前“展示过的最后一条数据的唯一标识（时间+ID）”**，这样你第二页可以对每个系统说：

  

> “从你那边我上次取到 B1（10:00:57）为止，下一页你从那里之后开始查”。

  

这样即使中间插入了 B_NEW（10:00:58），你下一页还能在排序中拿到它，它就不会漏掉。

---

**✅ 结论总结**

  

> 🚨 **只记录“当前页最晚（最小）时间”做游标，无法捕捉“中间插入”的数据，容易造成漏单。**

> ✅ **只有记录每个系统的最后游标位置（时间 + ID），才能精确控制分页进度，避免遗漏新插入的数据。**

---

如果你还想，我可以做成一个对比图表，或者模拟接口请求流程，更直观地帮你拿去解释别人也秒懂。要吗？