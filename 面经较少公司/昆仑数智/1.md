# 昆仑数智面经（问题 + 回答详尽版）

https://www.nowcoder.com/discuss/599617162306756608?sourceSSR=search

---

## 一、线程池 ThreadPoolExecutor

### Q1：ThreadPoolExecutor 的核心参数分别负责什么？
**A：构造函数如下，六大参数缺一不可：**

```java
ThreadPoolExecutor(
  int corePoolSize,
  int maximumPoolSize,
  long keepAliveTime,
  TimeUnit unit,
  BlockingQueue<Runnable> workQueue,
  ThreadFactory threadFactory,
  RejectedExecutionHandler handler
)
```

- `corePoolSize`：核心线程数，线程池中始终保留；即便闲置也不回收（除非 `allowCoreThreadTimeOut=true`），保障基础吞吐。
- `maximumPoolSize`：最大线程数，上限只在任务高峰且队列塞满时触发，继续扩容直到该值。
- `keepAliveTime + unit`：非核心线程空闲多久会被自动回收。
- `workQueue`：任务排队策略，常见实现  

常见阻塞队列如下：

| 队列                      | 特点                |
| ----------------------- | ----------------- |
| `ArrayBlockingQueue`    | 有界，容量固定，易做流控      |
| `LinkedBlockingQueue`   | 默认近似无界，适合消费速度稳定场景 |
| `SynchronousQueue`      | 不存储任务，需要线程即时接手    |
| `PriorityBlockingQueue` | 可设优先级，自定义排序规则     |

- `threadFactory`：统一创建线程，可设置线程名前缀、守护属性、优先级，方便排查。
- `RejectedExecutionHandler`：线程数已到 `maximumPoolSize` 且队列已满时决定如何处理新任务。

### Q2：一个任务从 `executor.execute()` 到落地执行的完整流程是什么？
**A：按“核心线程 → 队列 → 非核心线程 → 拒绝策略”顺序推进：**

1. **核心线程未满**：当前线程数 < `corePoolSize`，直接创建新线程执行，任务不会入队。
2. **核心线程已满**：尝试把任务放入队列，只要队列有空位就等待被调度。
3. **队列已满**：判断当前线程数 < `maximumPoolSize`，若可扩容则新建线程执行任务。
4. **线程与队列都满**：触发 `RejectedExecutionHandler`。  
一句话总结：先用核心线程 → 再排队 → 再扩容非核心线程 → 最后执行拒绝策略。

### Q3：常见拒绝策略怎么回答？适用场景？
**A：四种内置策略 + 自定义：**

| 策略                    | 场景                                               |
| --------------------- | ------------------------------------------------ |
| `AbortPolicy`（默认）     | 直接抛 `RejectedExecutionException`，适用于必须感知失败的核心任务。 |
| `CallerRunsPolicy`    | 由提交线程自己执行，通常用于削峰，防止无限制丢任务。                       |
| `DiscardPolicy`       | 悄悄丢弃最新任务，无回调，适用于对最终一致性要求不高的异步场景。                 |
| `DiscardOldestPolicy` | 丢队列最旧任务，再尝试插入新任务，适合新任务价值远大于旧任务的场景。               |
| 自定义策略                 | 可记录日志、报警或写入降级队列。                                 |

---

## 二、Spring Boot 常考注解

### Q4：启动与配置相关注解有哪些？如何作答？
**A：从“入口、配置、Bean、配置绑定”逐一列举：**

- `@SpringBootApplication` = `@SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan`
  - 作用：声明启动类、启用自动配置、开启包扫描（默认从该类所在包向下扫描 `@Component/@Service/...`）。
  - 示例：
    ```java
    @SpringBootApplication
    public class DemoApplication {
        public static void main(String[] args) {
            SpringApplication.run(DemoApplication.class, args);
        }
    }
    ```
- `@Configuration`：声明 Java 配置类（取代 XML）。
- `@Bean`：把方法返回值交给容器管理，常用于第三方类实例化。
- `@ConfigurationProperties(prefix = "xxx")`：批量把 `application.yml` 中的配置映射到实体。示例：
  ```yaml
  mail:
    host: smtp.example.com
    port: 25
    username: test
    password: 123456
  ```
  ```java
  @Component
  @ConfigurationProperties(prefix = "mail")
  @Data
  public class MailProperties {
      private String host;
      private Integer port;
      private String username;
      private String password;
  }
  ```

### Q5：Bean 注入相关注解如何区分？
**A：按职责拆分，面试时逐条说明：**

- `@Component`：最通用组件。
- `@Service`：业务逻辑层，方便做事务/AOP。
- `@Repository`：数据访问层，整合异常为 Spring DataAccessException。
- `@Controller`：传统 MVC，返回模板视图。
- `@RestController` = `@Controller + @ResponseBody`，直接返回 JSON。
- `@Autowired`：自动注入 Bean，建议配合构造器注入；若有多个实现，可搭配 `@Qualifier("beanName")` 指定。

示例：
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    public UserDO findById(Long id) {
        return userRepository.findById(id);
    }
}
```

### Q6：Web 层请求映射与参数接收怎么写？
**A：回答思路：先讲映射，再讲参数，最后补响应：**

- 请求映射：`@RequestMapping`（通用）以及 `@GetMapping/@PostMapping/@PutMapping/@DeleteMapping`。
- 参数注解：`@RequestParam`（查询参数，可指定 `defaultValue`）、`@PathVariable`（路径变量 `/users/{id}`）、`@RequestBody`（接收 JSON）、`@RequestHeader`、`@CookieValue`。
- 示例：
  ```java
  @RestController
  @RequestMapping("/api/order")
  public class OrderController {
      @GetMapping("/detail")
      public OrderDTO detail(@RequestParam Long id,
                             @RequestParam(defaultValue = "false") boolean includeItems) {
          return new OrderDTO();
      }
      @GetMapping("/{id}")
      public OrderDTO byPath(@PathVariable("id") Long orderId) {
          return new OrderDTO();
      }
      @PostMapping
      public OrderDTO create(@RequestBody CreateOrderRequest request) {
          return new OrderDTO();
      }
  }
  ```
- 响应相关：`@ResponseBody`（返回 JSON）、`@ResponseStatus`（自定义状态码）、`@CrossOrigin`（跨域）。

### Q7：事务、MyBatis、AOP、参数校验分别用什么注解？
**A：四项答法：**

1. `@Transactional(rollbackFor = Exception.class)`：声明式事务，默认放在 Service 层；说明它基于代理机制，`private/final` 方法或同类内部调用会失效。
   ```java
   @Service
   public class AccountService {
       @Autowired private AccountRepository accountRepository;

       @Transactional(rollbackFor = Exception.class)
       public void transfer(Long fromId, Long toId, BigDecimal amount) {
           accountRepository.decreaseBalance(fromId, amount);
           accountRepository.increaseBalance(toId, amount);
       }
   }
   ```
2. MyBatis：`@Mapper` 标在接口上或使用 `@MapperScan("com.xxx.mapper")`；也可用 `@Repository`。
3. AOP：`@Aspect` 声明切面，`@Before/@After/@Around` 分别表示前置/后置/环绕通知，用于日志、权限、接口耗时统计等。
4. 参数校验：`@Valid` 或 `@Validated` 触发 Bean Validation，如 `@NotBlank/@Size/@Email`；配合 `@ControllerAdvice + @ExceptionHandler` 汇总错误信息。

### Q8：定时任务、异步任务、配置注入要怎么讲？
**A：按“开启注解 + 业务注解 + 注意事项”来回答：**

- 定时任务：`@EnableScheduling` 打开调度能力，`@Scheduled(cron = "...")` 声明任务；方法一般无参、非 static、执行时间要短于调度周期。
  ```java
  @Configuration
  @EnableScheduling
  public class ScheduleConfig {}

  @Component
  public class ReportTask {
      @Scheduled(cron = "0 0 3 * * ?")
      public void generateDailyReport() {
          System.out.println("生成日报：" + LocalDateTime.now());
      }
  }
  ```
- 异步任务：`@EnableAsync + @Async`，注意同类内部调用无法异步，异步方法默认跑在 SimpleAsyncTaskExecutor，可自定义线程池。
  ```java
  @Service
  public class EmailService {
      @Async
      public void sendRegisterEmail(String to) {
          // 调用第三方服务
      }
  }
  ```
- 配置注入：少量字段用 `@Value("${app.name}")`；成块配置用 `@ConfigurationProperties`，可配合 `@Data`、`@Component`。
- 面试必背注解 Top10：`@SpringBootApplication、@RestController、@RequestMapping/@GetMapping/@PostMapping、@Autowired、@Service、@Component、@Configuration、@Bean、@Transactional、@Scheduled`。

---

## 三、MySQL 优化、索引与内存

### Q9：如果被问“你怎么做 MySQL 优化”，回答框架是什么？
**A：分四个层面：SQL、索引、表结构、架构：**

1. **SQL 层面**
   - 避免 `SELECT *`，只查必要列。
   - WHERE 条件里不要对列做函数/计算，防止索引失效（如 `WHERE YEAR(create_time)=2025`）。
   - 模糊查询尽量用 `LIKE 'xxx%'` 而不是 `%xxx`。
   - 控制返回结果：`LIMIT`、分页、去重。
   - 减少子查询，能 JOIN 就 JOIN，避免 N+1。
2. **索引层面**
   - 高频查询条件、排序、分组字段建索引。
   - 合理设计联合索引，遵循最左前缀原则。
   - 避免以下导致索引失效：对索引列使用函数、前导 `%`、隐式类型转换（如字符串列跟数字比较）、`OR` 连接不同字段且没覆盖索引。
3. **表结构层面**
   - 字段类型精简（能 INT 不用 BIGINT，能 VARCHAR 不用 TEXT）。
   - 使用自增主键（InnoDB 聚簇索引更友好）。
   - 热数据与冷数据分表，大表拆分。
4. **系统架构层面**
   - 读写分离、分库分表、引入缓存（Redis）减轻数据库压力。

### Q10：什么是“回表”？面试中怎么解释？
**A：完整回答包含定义 + 示例 + 如何优化：**

- 定义：在二级索引中只能拿到索引列和主键值。当查询列不在索引中时，需要“先在二级索引查到主键，再回到主键索引（聚簇索引）读取整行数据”，这一来回称为回表，意味着多一次磁盘 IO。
- 示例：
  - 表结构  
    ```sql
    CREATE TABLE user (
      id BIGINT PRIMARY KEY,
      name VARCHAR(50),
      age INT,
      email VARCHAR(100),
      INDEX idx_name(name)
    );
    ```
  - `SELECT name FROM user WHERE name = 'Tom';` ——索引已经覆盖查询列，无需回表。
  - `SELECT email FROM user WHERE name = 'Tom';` ——需要先用 `idx_name` 找到主键，再回主键索引取 `email`，发生回表。
- 如何减少：建设覆盖索引（如 `CREATE INDEX idx_name_email ON user(name, email);`），或直接按主键查询。

### Q11：被问“你会如何调整 MySQL 内存参数”时怎么答？
**A：重点讲 InnoDB 相关内存池：**

1. `innodb_buffer_pool_size`
   - 核心参数，缓存数据页和索引页，减少磁盘 IO。
   - 若 MySQL 独占服务器，建议设为物理内存的 60%~80%。
   - 查看：`SHOW VARIABLES LIKE 'innodb_buffer_pool_size';`
2. `innodb_log_buffer_size`
   - 事务日志写入缓存，适合大事务/批量写场景；调大可以减少刷盘次数。
3. `sort_buffer_size`
   - 排序时每个线程分配的内存，作用于 `ORDER BY/GROUP BY`。是 per-thread，不宜设置过大，否则高并发易 OOM。
4. `join_buffer_size`
   - 没有使用索引的 JOIN 会用到，适当增大可提升性能，同样是 per-thread。

总结回答示例：  
> “MySQL 内存优化主要围绕 InnoDB Buffer Pool、日志缓冲以及排序/连接缓冲。首先确保 `innodb_buffer_pool_size` 足够大缓存热点数据，其次根据事务和批量写入情况调节 `innodb_log_buffer_size`，再视排序和 JOIN 的特征合理设置 `sort_buffer_size`、`join_buffer_size`，以此减少磁盘 IO。”

---

## 四、TCP/IP 与 HTTPS 高频题

### Q12：如何解释 TCP/IP 模型？
**A：结合四层 + 对应 OSI + 常见协议：**

| TCP/IP 层 | 对应 OSI | 主要功能 | 常见协议 |
| --- | --- | --- | --- |
| 应用层 | 应用 + 表示 + 会话 | 面向用户的应用服务 | HTTP、HTTPS、FTP、DNS、SMTP |
| 传输层 | 传输层 | 端到端通信 | TCP（面向连接、可靠、有序，带流控和拥塞控制）、UDP（无连接、尽力而为、低延迟，常用于语音、视频、DNS） |
| 网络层 | 网络层 | IP 寻址、路由转发 | IP、ICMP（ping）、ARP（IP ↔ MAC 解析） |
| 网络接口层 | 数据链路层 + 物理层 | 物理传输 | Ethernet、Wi-Fi、PPP 等 |

面试时可按“1️⃣ 应用层… 2️⃣ 传输层…”口头输出，突出 TCP 有序可靠、UDP 快速简洁等关键词。

### Q13：HTTPS 是什么？解决了哪些 HTTP 问题？
**A：从定义到痛点：**

- 定义：HTTPS = HTTP + SSL/TLS，是在传输层上加了一层加密/认证层的安全协议。
- HTTP 的三大风险：窃听（明文被抓包）、篡改（数据被修改）、冒充（伪造服务器）。
- HTTPS 通过加密（防窃听）、完整性校验（防篡改）、数字证书（身份认证）解决上述问题，默认端口 443，可顺带提 CA 证书链。

### Q15：TLS/SSL 握手流程怎么讲？
**A：结合 TCP + TLS 两阶段：**

1. **TCP 三次握手**：完成基本连接。
2. **TLS 四步握手（简化版）**
   - ClientHello：客户端发送支持的加密算法、TLS 版本、随机数。
   - ServerHello：服务端返回选定算法、证书、公钥、随机数。
   - 证书验证 + PreMaster：客户端验证证书合法性，通过后生成对称密钥，用服务端公钥加密发送。
   - Secret 建立：服务端用私钥解密得到对称密钥，双方后续通信都用该对称密钥加密。

### Q16：HTTPS 为什么要同时用对称和非对称加密？
**A：一句回答、两点解释：**

- 非对称加密安全但慢，适合在握手阶段安全交换密钥。
- 对称加密效率高，适合大量业务数据传输。
- 组合使用：先用非对称加密交换会话密钥，再用对称加密传输数据，既安全又高效；补充可提 Session-Resumption、HTTP/2、硬件加速等优化性能的手段。

### Q17：面试官追问 HTTPS 还有哪些点？
**A：提前准备几个常见追问：**

- HTTPS 是否绝对安全？答：不绝对，CA 被攻击或终端被植入木马仍有风险，可引申双向 TLS、HSTS 等。
- 默认端口？443。
- 性能损耗？主要在握手与加解密，但现代硬件 + Session 复用 + HTTP/2 让差异可忽略。
- 如何防中间人攻击？依赖 CA 证书链验证、公钥基础设施、可选双向认证。
