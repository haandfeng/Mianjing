# 昆仑数智面经（问答结构版）
https://www.nowcoder.com/discuss/603726385772855296?sourceSSR=search
---

## Q1：Java 八种基本数据类型怎么回答？

**A：按“整数 / 浮点 / 字符 / 布尔”四类记忆，并补充包装类：**

| 类型 | 关键字 | 字节 | 说明 |
| --- | --- | --- | --- |
| 整数 | `byte` | 1 | -128 ~ 127 |
|  | `short` | 2 | 16 位整数 |
|  | `int` | 4 | 最常用 |
|  | `long` | 8 | 结尾可写 `L` |
| 浮点 | `float` | 4 | 单精度，字面量加 `F` |
|  | `double` | 8 | 双精度，默认浮点 |
| 字符 | `char` | 2 | Unicode 字符 |
| 布尔 | `boolean` | JVM 决定 | 只有 `true/false` |

> 补充：每种基本类型都有对应包装类，如 `int -> Integer`，用于集合、泛型、工具方法。

---

## Q2：如何面试化描述“面向对象”思想？

**A：写成一句话 + 四个关键词 + 工程价值：**

- 面向对象是把现实中的事物抽象成对象，通过 **封装、继承、多态、抽象** 来组织代码。
- **封装**：隐藏实现，只暴露 API。  
- **继承**：复用共性，实现层次结构。  
- **多态**：同一接口多种表现，提升扩展性。  
- **抽象**：抽取本质，屏蔽细节。

> 工程视角：实现“高内聚、低耦合”，让系统易维护、易扩展。

---

## Q3：抽象类 vs 接口我总记混？请把区别讲清楚。

**A：从设计目的、语法特性、使用场景三个维度拆开理解：**

### 1. 设计目的
- **抽象类**：描述“是一种”（is-a）的共性，有统一的属性和部分实现。  
- **接口**：描述“能做什么”的能力标准，只约定方法签名，让不同类型的类都能实现同一能力。

### 2. 语法/能力差异
| 对比项 | 抽象类 | 接口（Java 8+） |
| --- | --- | --- |
| 关键字 | `abstract class` | `interface` |
| 继承/实现 | 只能单继承 | 一个类可实现多个接口 |
| 成员 | 可有普通/静态变量、构造器、普通方法、抽象方法 | 成员变量默认 `public static final`；支持抽象方法、`default` 方法、`static` 方法 |
| 访问修饰 | 可使用多种修饰符 | 方法默认 `public`（`default` 方法除外） |

### 3. 何时用谁？
- 若要抽象“一类事物”并复用公共逻辑，用抽象类（例：`abstract class Animal` 提供 `eat()` 默认实现，`makeSound()` 留给子类）。  
- 若要定义一组能力，让不同对象都能实现，用接口（例：`Comparable`、`Serializable`）。  
- 实际项目中：类可以“extends 抽象父类 + implements 多个接口”，兼顾共享实现和能力扩展。

> 记忆口号：**“抽象类强调共性和默认实现，接口强调规范和能力扩展”**。

---

## Q4：MyBatis 里的 `#{}` 和 `${}` 有啥区别？为什么一直说 `${}` 危险？

**A：关键在于“是否预编译、能否防注入”：**

| 特性 | `#{}`（推荐） | `${}`（慎用） |
| --- | --- | --- |
| 替换方式 | 转换成 `?` 占位符 | 直接字符串拼接 |
| SQL 执行 | `PreparedStatement` 预编译 | 动态拼接后再执行 |
| 类型转换 | MyBatis 自动完成 | 需要手动保证格式 |
| 安全性 | 可防 SQL 注入 | 容易被注入 |
| 典型用途 | WHERE 条件、INSERT/UPDATE 值 | 动态表名、列名、排序字段等 |

### 示例
```xml
<!-- #{} 用于安全传值 -->
<select id="selectUser" resultType="User">
  SELECT * FROM user WHERE name = #{name}
</select>
-- 实际发送：SELECT * FROM user WHERE name = ?;

<!-- ${} 用来拼接对象名等 -->
<select id="selectOrder" resultType="Order">
  SELECT * FROM ${tableName} ORDER BY ${column}
</select>
```

> 总结：  
> - `#{}` 预编译并自动做类型转换，几乎所有用户输入都应该用它；  
> - `${}` 会把内容原样拼进 SQL，只能在拼接表名/列名等受控场景使用，绝不能直接接收用户输入。

---

## Q5：Spring 中常用的参数接收注解有哪些？

**A：面试常考的是以下三大类，记住来源即可：**

- `@RequestParam`：绑定 URL 查询参数或表单字段。  
- `@PathVariable`：绑定 RESTful URL 中的路径占位符。  
- `@RequestBody`：绑定请求体中的 JSON/XML。  
- 其他：`@RequestHeader`、`@CookieValue`、`@ModelAttribute` 等，了解即可。

---

## Q6：`@RequestParam`、`@PathVariable`、`@RequestBody` 的用法与区别？

### 1. `@RequestParam` —— URL `?key=value` / 表单字段
```java
// GET /user/list?page=1&size=10
@GetMapping("/user/list")
public List<UserDTO> list(
        @RequestParam(defaultValue = "1") Integer page,
        @RequestParam(defaultValue = "10") Integer size) {
    ...
}
```
- 来源：查询参数、`application/x-www-form-urlencoded` 表单。
- 支持 `required`, `defaultValue`。

### 2. `@PathVariable` —— RESTful 路径占位符
```java
// GET /user/100
@GetMapping("/user/{id}")
public UserDTO getUser(@PathVariable("id") Long userId) {
    ...
}
```
- 来源：URL 中的 `{id}` 等。
- 与 `@RequestParam` 区别：一个在路径、一个在查询参数。

### 3. `@RequestBody` —— 请求体 JSON/XML
```java
@PostMapping("/user")
public UserDTO createUser(@RequestBody CreateUserRequest request) {
    ...
}
```
- 需要 `Content-Type: application/json`（或 XML）。
- 依赖消息转换器（Jackson 等）把 JSON 映射成对象。
- 通常一个接口只有一个 `@RequestBody` 参数。

### 4. 面试总结
> - `@RequestParam`：接查询/表单参数，适合简单类型和分页。  
> - `@PathVariable`：接 RESTful 路径变量，如 `/user/{id}`。  
> - `@RequestBody`：接请求体 JSON，适合提交 DTO。  
> - 实战习惯：GET 用 `@RequestParam/@PathVariable`，POST/PUT 传 JSON 用 `@RequestBody`。
