# 昆仑数智面经（今日面试问答）

---

## Q1：什么是敏捷开发？

**A：敏捷开发是一种以人为核心、迭代、循序渐进的开发方法论，强调快速响应变化和持续交付价值。**

### 面试总结
> 敏捷开发通过短周期迭代、频繁交付、团队协作和快速响应变化，提高开发效率和产品质量，适合需求变化快的项目。

---

## Q2：说一下关系型数据库的索引是什么？

**A：索引是数据库中用于快速定位数据的数据结构，类似于书籍的目录，可以大幅提升查询性能。**

### 1. 索引的本质
- **数据结构**：通常是 B+ 树（InnoDB）或 B 树，有序存储索引列的值和对应的行指针
- **存储位置**：索引和数据可以分开存储（非聚簇索引）或存储在一起（聚簇索引）

### 2. 索引的作用
- **加速查询**：避免全表扫描，通过索引快速定位到目标数据
- **加速排序**：`ORDER BY` 和 `GROUP BY` 可以利用索引的有序性
- **保证唯一性**：唯一索引确保列值不重复
- **加速连接**：JOIN 操作时，索引可以快速匹配关联字段

### 3. 索引的类型
| 类型 | 说明 | 示例 |
| --- | --- | --- |
| **主键索引** | 聚簇索引，唯一且非空 | `PRIMARY KEY (id)` |
| **唯一索引** | 保证列值唯一 | `UNIQUE INDEX idx_email (email)` |
| **普通索引** | 最常用，无特殊约束 | `INDEX idx_name (name)` |
| **联合索引** | 多列组合索引 | `INDEX idx_name_age (name, age)` |
| **全文索引** | 用于文本搜索 | `FULLTEXT INDEX idx_content (content)` |

### 4. 索引的底层实现（以 MySQL InnoDB 为例）
- **聚簇索引（主键索引）**：
  - 数据行直接存储在 B+ 树的叶子节点
  - 一个表只有一个聚簇索引
  - 主键查询最快
  
- **非聚簇索引（二级索引）**：
  - 叶子节点存储索引列值 + 主键值
  - 查询时需要“回表”：先查索引得到主键，再通过主键查完整行
  - 可以通过覆盖索引避免回表

### 5. 索引的优缺点
**优点**：

- 大幅提升查询速度（特别是 WHERE、JOIN、ORDER BY）
- 加速排序和分组
- 保证数据唯一性

**缺点**：
- 占用额外存储空间
- 降低 INSERT、UPDATE、DELETE 速度（需要维护索引）
- 索引过多会影响写性能

### 6. 索引使用注意事项
- **最左前缀原则**：联合索引 `(a, b, c)` 可以用于 `WHERE a = ?`、`WHERE a = ? AND b = ?`，但不能直接用于 `WHERE b = ?`
- **索引失效场景**：
  - 对索引列使用函数：`WHERE YEAR(create_time) = 2024`
  - 模糊查询前导 `%`：`WHERE name LIKE '%Tom'`
  - 隐式类型转换：`WHERE phone = 13812345678`（phone 是字符串）
  - `OR` 连接不同字段：`WHERE a = 1 OR b = 2`
  - 使用 `!=`、`<>`、`NOT IN`（某些情况下）

### 面试总结
> 索引是数据库中的数据结构（通常是 B+ 树），用于加速查询。主键索引是聚簇索引，数据直接存储在索引中；普通索引是非聚簇索引，需要回表查询。合理使用索引可以大幅提升查询性能，但要注意索引维护成本和失效场景。

---

## Q3：ES 的索引是什么，怎么查询文档的？

**A：ES（Elasticsearch）的索引是文档的集合，类似于关系型数据库中的“数据库+表”的概念。查询文档主要通过 RESTful API 或 DSL 查询语言实现。**

### 1. ES 索引的概念
- **类比**：ES 索引 ≈ 关系型数据库的“数据库+表”
- **结构**：
  - **索引（Index）**：文档的集合
  - **类型（Type）**：ES 7.x 后已废弃，一个索引只有一个 `_doc` 类型
  - **文档（Document）**：JSON 格式的数据，相当于表中的一行
  - **字段（Field）**：文档的属性，相当于表中的列

### 2. ES 索引的底层实现
- **倒排索引（Inverted Index）**：
  - 以词条（Term）为键，文档 ID 列表为值
  - 例如：`"Java" -> [doc1, doc3, doc5]`
  - 支持全文搜索，查询速度极快
  
- **分片（Shard）**：
  - 索引可以分成多个分片，分布在不同节点
  - 主分片（Primary Shard）和副本分片（Replica Shard）
  - 支持水平扩展和容错

### 面试总结
> ES 索引是文档的集合，底层使用倒排索引实现全文搜索。查询文档主要通过 RESTful API 发送 DSL 查询。

---

## Q4：对微服务的理解？

**A：微服务是一种架构风格，将单体应用拆分为多个独立部署、独立运行的小型服务，每个服务专注于单一业务功能，通过轻量级通信机制协作。**

###  微服务的核心特征
- **服务拆分**：按业务领域或功能模块拆分成独立服务
- **独立部署**：每个服务可以独立开发、测试、部署、扩展
- **技术异构**：不同服务可以使用不同的技术栈
- **去中心化**：数据管理、治理去中心化
- **故障隔离**：单个服务故障不影响整体系统

### 面试总结
> 微服务是将单体应用拆分为多个独立服务，每个服务独立部署、独立扩展，通过轻量级通信协作。优势是技术灵活、独立扩展、故障隔离；挑战是分布式复杂性、运维复杂、服务治理。需要配合服务注册、配置中心、网关、熔断等组件构建完整的微服务架构。

---

## Q5：Nacos 怎么进行注册发现？

**A：Nacos 通过服务提供者向注册中心注册服务信息，服务消费者从注册中心拉取服务列表，实现服务发现。支持 AP 和 CP 两种一致性模式。**

### 1. 服务注册流程

#### ① 服务提供者注册
```java
// Spring Cloud Alibaba 方式
@SpringBootApplication
@EnableDiscoveryClient  // 启用服务发现
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
```

**配置文件（application.yml）**：
```yaml
spring:
  application:
    name: user-service  # 服务名
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848  # Nacos 服务器地址
        namespace: dev  # 命名空间（可选）
        group: DEFAULT_GROUP  # 分组（可选）
        cluster-name: BEIJING  # 集群名（可选）
```

#### ② 注册过程
1. **服务启动时**：应用向 Nacos Server 发送注册请求
2. **Nacos Server**：将服务信息（服务名、IP、端口、元数据）存储到注册表
3. **心跳机制**：服务定期发送心跳（默认 5 秒），保持服务在线状态
4. **健康检查**：Nacos 检测到心跳超时（默认 15 秒），将服务标记为不健康

### 2. 服务发现流程

#### ① 服务消费者发现
```java
@RestController
public class OrderController {
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private DiscoveryClient discoveryClient;  // 服务发现客户端
    
    @GetMapping("/order/{id}")
    public Order getOrder(@PathVariable Long id) {
        // 方式1：通过 DiscoveryClient 获取服务列表
        List<ServiceInstance> instances = discoveryClient.getInstances("user-service");
        ServiceInstance instance = instances.get(0);
        String url = "http://" + instance.getHost() + ":" + instance.getPort() + "/user/" + id;
        
        // 方式2：使用 @LoadBalanced 的 RestTemplate（自动负载均衡）
        // String url = "http://user-service/user/" + id;
        
        return restTemplate.getForObject(url, Order.class);
    }
}
```

#### ② 使用 OpenFeign（推荐）
```java
@FeignClient(name = "user-service", path = "/user")
public interface UserServiceClient {
    @GetMapping("/{id}")
    User getUserById(@PathVariable Long id);
}

@RestController
public class OrderController {
    @Autowired
    private UserServiceClient userServiceClient;
    
    @GetMapping("/order/{id}")
    public Order getOrder(@PathVariable Long id) {
        User user = userServiceClient.getUserById(id);
        // ...
    }
}
```

### 3. Nacos 注册发现的核心机制

#### ① 服务注册表结构
```
服务名（user-service）
  ├── 集群1（BEIJING）
  │   ├── 实例1：192.168.1.100:8080（健康）
  │   └── 实例2：192.168.1.101:8080（健康）
  └── 集群2（SHANGHAI）
      └── 实例3：192.168.1.102:8080（健康）
```

#### ② 服务发现模式
- **Pull 模式**：客户端定时从 Nacos 拉取服务列表（默认）
- **Push 模式**：Nacos 主动推送服务变更给客户端（需要配置）

#### ③ 一致性协议
- **AP 模式**（默认）：保证可用性和分区容错性，适合服务发现场景
- **CP 模式**：保证一致性和分区容错性，适合配置管理场景

### 5. 高级特性
- **命名空间（Namespace）**：环境隔离（dev、test、prod）
- **分组（Group）**：服务分组管理
- **集群（Cluster）**：同地域服务集群，优先调用同集群服务
- **权重**：服务实例权重，用于负载均衡
- **元数据**：自定义服务元数据

### 面试总结
> Nacos 服务注册：服务启动时向 Nacos Server 注册服务信息（服务名、IP、端口），通过心跳保持在线。服务发现：消费者从 Nacos 拉取服务列表，通过服务名调用服务，支持负载均衡。Nacos 支持命名空间、分组、集群等特性，默认使用 AP 模式保证高可用。

---

## Q6：Sentinel 怎么进行服务限流、线程隔离、服务降级？

==看yelp like代码吧。感觉这个没有什么意义，有点蠢==
**A：Sentinel 通过定义规则（流控规则、隔离规则、降级规则）和注解（@SentinelResource）实现限流、隔离和降级，配合 Dashboard 进行可视化管理和监控。**

### 1. 服务限流（Flow Control）

#### ① 流控规则配置
```java
// 方式1：代码配置
@PostConstruct
public void initFlowRules() {
    List<FlowRule> rules = new ArrayList<>();
    FlowRule rule = new FlowRule();
    rule.setResource("getUserById");  // 资源名
    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);  // 限流类型：QPS
    rule.setCount(10);  // 阈值：每秒 10 次
    rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_DEFAULT);  // 直接拒绝
    rules.add(rule);
    FlowRuleManager.loadRules(rules);
}
```

```yaml
# 方式2：配置文件（Spring Cloud Alibaba）
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8080  # Sentinel Dashboard 地址
      datasource:
        flow:
          nacos:
            server-addr: localhost:8848
            dataId: ${spring.application.name}-flow-rules
            groupId: SENTINEL_GROUP
            rule-type: flow
```

#### ② 限流策略
- **QPS 限流**：限制每秒请求数
- **线程数限流**：限制并发线程数
- **关联限流**：关联资源达到阈值时，限流当前资源
- **链路限流**：只统计指定链路上的流量

#### ③ 流控效果
- **直接拒绝**：超过阈值直接抛异常
- **Warm Up**：冷启动，逐步增加阈值
- **匀速排队**：超过阈值后排队等待，匀速通过

#### ④ 使用示例
```java
@RestController
public class UserController {
    @GetMapping("/user/{id}")
    @SentinelResource(value = "getUserById", blockHandler = "blockHandler")
    public User getUserById(@PathVariable Long id) {
        return userService.getUserById(id);
    }
    
    // 限流降级方法
    public User blockHandler(@PathVariable Long id, BlockException e) {
        return new User("限流了，请稍后再试");
    }
}
```

### 2. 线程隔离（Thread Isolation）

#### ① 线程池隔离
```java
// 自定义线程池
@Bean
public ExecutorService userServiceExecutor() {
    return new ThreadPoolExecutor(
        10,  // 核心线程数
        20,  // 最大线程数
        60L, TimeUnit.SECONDS,
        new LinkedBlockingQueue<>(100)
    );
}

// 使用线程池执行
@SentinelResource(value = "getUserById", 
                  fallback = "fallback",
                  fallbackClass = UserServiceFallback.class)
public CompletableFuture<User> getUserByIdAsync(Long id) {
    return CompletableFuture.supplyAsync(() -> {
        return userService.getUserById(id);
    }, userServiceExecutor);
}
```

#### ② 信号量隔离（Semaphore）
```java
// 通过 Sentinel 规则配置信号量
@PostConstruct
public void initIsolationRules() {
    List<DegradeRule> rules = new ArrayList<>();
    DegradeRule rule = new DegradeRule();
    rule.setResource("getUserById");
    rule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT);  // 异常数降级
    rule.setCount(5);  // 异常数阈值
    rule.setTimeWindow(10);  // 时间窗口（秒）
    rules.add(rule);
    DegradeRuleManager.loadRules(rules);
}
```

### 3. 服务降级（Circuit Breaker）

#### ① 降级规则配置
```java
@PostConstruct
public void initDegradeRules() {
    List<DegradeRule> rules = new ArrayList<>();
    DegradeRule rule = new DegradeRule();
    rule.setResource("getUserById");
    
    // 降级策略1：慢调用比例
    rule.setGrade(RuleConstant.DEGRADE_GRADE_RT);  // 平均响应时间
    rule.setCount(500);  // RT 阈值（毫秒）
    rule.setTimeWindow(10);  // 时间窗口
    rule.setMinRequestAmount(5);  // 最小请求数
    rule.setSlowRatioThreshold(0.5);  // 慢调用比例阈值
    
    // 降级策略2：异常比例
    // rule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO);
    // rule.setCount(0.5);  // 异常比例阈值
    
    // 降级策略3：异常数
    // rule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT);
    // rule.setCount(5);  // 异常数阈值
    
    rules.add(rule);
    DegradeRuleManager.loadRules(rules);
}
```

#### ② 降级策略类型
| 策略 | 说明 | 适用场景 |
| --- | --- | --- |
| **慢调用比例** | 统计时间窗口内慢调用比例，超过阈值触发降级 | 接口响应慢 |
| **异常比例** | 统计时间窗口内异常比例，超过阈值触发降级 | 接口异常率高 |
| **异常数** | 统计时间窗口内异常数，超过阈值触发降级 | 接口异常数多 |

#### ③ 使用示例
```java
@RestController
public class UserController {
    @GetMapping("/user/{id}")
    @SentinelResource(
        value = "getUserById",
        fallback = "fallback",  // 降级方法
        fallbackClass = UserServiceFallback.class,
        blockHandler = "blockHandler"  // 限流方法
    )
    public User getUserById(@PathVariable Long id) {
        // 模拟慢调用或异常
        if (id < 0) {
            throw new RuntimeException("参数错误");
        }
        return userService.getUserById(id);
    }
    
    // 降级方法（同类中）
    public User fallback(@PathVariable Long id, Throwable e) {
        return new User("服务降级，返回默认值");
    }
}

// 降级类（外部类）
public class UserServiceFallback {
    public static User fallback(Long id, Throwable e) {
        return new User("服务降级，请稍后重试");
    }
}
```

### 4. Sentinel Dashboard 使用
- **实时监控**：查看 QPS、RT、异常数等指标
- **规则管理**：可视化配置流控、降级、系统规则
- **集群限流**：配置集群流控规则
- **热点参数限流**：对热点参数进行限流

### 5. 完整示例（Spring Cloud Alibaba）
```yaml
# application.yml
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8080
      datasource:
        # 流控规则
        flow:
          nacos:
            server-addr: localhost:8848
            dataId: ${spring.application.name}-flow-rules
            groupId: SENTINEL_GROUP
            rule-type: flow
        # 降级规则
        degrade:
          nacos:
            server-addr: localhost:8848
            dataId: ${spring.application.name}-degrade-rules
            groupId: SENTINEL_GROUP
            rule-type: degrade
```

### 面试总结
> Sentinel 限流：通过流控规则限制 QPS 或线程数，支持直接拒绝、Warm Up、匀速排队。线程隔离：通过线程池或信号量隔离资源，避免资源耗尽。服务降级：通过降级规则（慢调用比例、异常比例、异常数）触发降级，调用降级方法返回默认值。配合 Dashboard 可以可视化管理和监控。

---

## Q7：OpenFeign 怎么做网关？

**A：OpenFeign 是服务调用客户端，不是网关。网关通常使用 Spring Cloud Gateway 或 Zuul。这里补充说明 OpenFeign 的服务调用方式，以及 Gateway 的网关实现。**

### 1. OpenFeign 的作用（服务调用，非网关）

#### ① OpenFeign 简介
- **定位**：声明式 HTTP 客户端，用于服务间调用
- **特点**：通过接口 + 注解定义服务调用，简化 HTTP 请求

#### ② 使用示例
```java
// 1. 添加依赖
// spring-cloud-starter-openfeign

// 2. 启用 Feign
@SpringBootApplication
@EnableFeignClients  // 启用 Feign 客户端
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}

// 3. 定义 Feign 客户端接口
@FeignClient(name = "user-service", path = "/user")
public interface UserServiceClient {
    @GetMapping("/{id}")
    User getUserById(@PathVariable Long id);
    
    @PostMapping
    User createUser(@RequestBody CreateUserRequest request);
}

// 4. 使用
@RestController
public class OrderController {
    @Autowired
    private UserServiceClient userServiceClient;
    
    @GetMapping("/order/{id}")
    public Order getOrder(@PathVariable Long id) {
        User user = userServiceClient.getUserById(id);
        // ...
    }
}
```

#### ③ Feign 配置
```yaml
# application.yml
feign:
  client:
    config:
      default:
        connectTimeout: 5000  # 连接超时
        readTimeout: 5000     # 读取超时
      user-service:  # 针对特定服务
        connectTimeout: 3000
        readTimeout: 3000
  compression:
    request:
      enabled: true  # 请求压缩
    response:
      enabled: true  # 响应压缩
```

### 2. Spring Cloud Gateway（真正的网关）


#### ① Gateway 简介
- **定位**：API 网关，统一入口，路由转发、过滤、限流
- **特点**：基于 WebFlux 响应式编程，性能高

#### ② 使用示例
```java
// 1. 添加依赖
// spring-cloud-starter-gateway

// 2. 配置文件路由
# application.yml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service-route
          uri: lb://user-service  # lb 表示负载均衡
          predicates:
            - Path=/user/**
          filters:
            - StripPrefix=1  # 去掉前缀 /user
        - id: order-service-route
          uri: lb://order-service
          predicates:
            - Path=/order/**
          filters:
            - StripPrefix=1
      globalcors:  # 跨域配置
        cors-configurations:
          '[/**]':
            allowedOrigins: "*"
            allowedMethods: "*"
            allowedHeaders: "*"
```

#### ③ 代码配置路由
```java
@Configuration
public class GatewayConfig {
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("user-service", r -> r
                .path("/user/**")
                .filters(f -> f.stripPrefix(1))
                .uri("lb://user-service"))
            .route("order-service", r -> r
                .path("/order/**")
                .filters(f -> f.stripPrefix(1))
                .uri("lb://order-service"))
            .build();
    }
}
```

#### ④ Gateway 过滤器
```java
// 全局过滤器
@Component
public class AuthFilter implements GlobalFilter, Ordered {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String token = request.getHeaders().getFirst("token");
        
        if (token == null || !isValid(token)) {
            ServerHttpResponse response = exchange.getResponse();
            response.setStatusCode(HttpStatus.UNAUTHORIZED);
            return response.setComplete();
        }
        
        return chain.filter(exchange);
    }
    
    @Override
    public int getOrder() {
        return -1;  // 优先级
    }
}
```

#### ⑤ Gateway 集成 Sentinel
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/user/**
    sentinel:
      transport:
        dashboard: localhost:8080
      scg:
        fallback:
          mode: response  # 降级模式
          response-body: '{"code":500,"message":"服务不可用"}'
```

### 3. 网关的作用
- **统一入口**：所有外部请求通过网关进入
- **路由转发**：根据路径转发到不同服务
- **负载均衡**：集成 Ribbon/LoadBalancer
- **限流熔断**：集成 Sentinel/Hystrix
- **认证鉴权**：统一处理 token 验证
- **日志监控**：统一日志收集和监控
- **跨域处理**：统一处理 CORS

### 面试总结
> OpenFeign 是服务调用客户端，通过接口 + 注解简化服务间 HTTP 调用，不是网关。真正的网关使用 Spring Cloud Gateway，通过路由规则将请求转发到后端服务，支持过滤器、限流、熔断等功能。Gateway 基于 WebFlux 响应式编程，性能优于 Zuul。


==感觉还是要看看代码这些组件是最没用的==

---



